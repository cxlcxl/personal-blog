[{"content":"先上 github-acitons 部署 yml 文件内容 name: 部署到服务器 on: push: branches: [ \u0026#34;master\u0026#34; ] # master 分支有提交自动部署 permissions: write-all jobs: deploy: name: Deploy runs-on: ubuntu-latest environment: production steps: # 获取源码 master 分支，也可以写 tag 版本 - name: Checkout uses: actions/checkout@master # 使用到的这个 easingthemes/ssh-deploy actions，main 表示主分支 # 可以直接仓库搜索到：easingthemes/ssh-deploy，有介绍下面的配置项 - name: 部署到服务器 uses: easingthemes/ssh-deploy@main env: SSH_PRIVATE_KEY: ${{ secrets.BLOG_ECS_KEY }} ARGS: \u0026#34;-avzr --delete\u0026#34; # 部署前删除目录 SOURCE: \u0026#34;public/\u0026#34; REMOTE_HOST: ${{ secrets.BLOG_ECS_HOST }} REMOTE_USER: ${{ secrets.BLOG_ECS_USER }} TARGET: ${{ secrets.BLOG_ECS_TARGET }} 首先开启 github 仓库的 actions 功能 两种方式\n第一种 进入 github 找到你要部署的仓库 进入 actions 后点击 -\u0026gt; Skip this and **set up a workflow yourself** 编写 yml 文件 第二种 直接在项目根目录创建 .github/workflows/deploy.yml 随项目一起提交（文件名可自定义）\neasingthemes/ssh-deploy 配置 SSH_PRIVATE_KEY\n按以下步骤执行\n进入你的服务器，在 /root/.ssh/ 目录查看是否有 id_rsa.pub 公钥和 id_rsa 私钥 没有：运行 ssh-keygen -m PEM -t rsa -b 4096 生成，有就跳过此步 cp id_rsa.pub authorized_keys cat id_rsa 查看并复制私钥，要复制全部内容 此时回到仓库，将第4步复制的私钥填入仓库的 settings.Secrets.Actions 按照定义的 key.value 添加 SOURCE\n要部署的项目目录，如 dist,public\nREMOTE_HOST\n服务器 IP\nREMOTE_USER\n服务器用户名\nTARGET\n要部署到服务器哪个目录\n","permalink":"https://www.silent-cxl.top/posts/deploy-github-actions/","summary":"先上 github-acitons 部署 yml 文件内容 name: 部署到服务器 on: push: branches: [ \u0026#34;master\u0026#34; ] # master 分支有提交自动部署 permissions: write-all jobs: deploy: name: Deploy runs-on: ubuntu-latest environment: production steps: # 获取源码 master 分支，也可以写 tag 版本 - name: Checkout uses: actions/checkout@master # 使用到的这个 easingthemes/ssh-deploy actions，main 表示主分支 # 可以直接仓库搜索到：easingthemes/ssh-deploy，有介绍下面的配置项 - name: 部署到服务器 uses: easingthemes/ssh-deploy@main env: SSH_PRIVATE_KEY: ${{ secrets.BLOG_ECS_KEY }} ARGS: \u0026#34;-avzr --delete\u0026#34; # 部署前删除目录 SOURCE: \u0026#34;public/\u0026#34; REMOTE_HOST: ${{ secrets.BLOG_ECS_HOST }} REMOTE_USER: ${{ secrets.BLOG_ECS_USER }} TARGET: ${{ secrets.","title":"记录 Github Actions 实现代码提交自动部署"},{"content":"// func shuffle[T any](slice []T) { // go1.18 及以上 func shuffle(slice []int64) { if len(slice) == 1 { return } r := rand.New(rand.NewSource(time.Now().UnixNano())) for len(slice) \u0026gt; 0 { n := len(slice) randIndex := r.Intn(n) slice[n-1], slice[randIndex] = slice[randIndex], slice[n-1] slice = slice[:n-1] } } ","permalink":"https://www.silent-cxl.top/posts/go-shuffle/","summary":"// func shuffle[T any](slice []T) { // go1.18 及以上 func shuffle(slice []int64) { if len(slice) == 1 { return } r := rand.New(rand.NewSource(time.Now().UnixNano())) for len(slice) \u0026gt; 0 { n := len(slice) randIndex := r.Intn(n) slice[n-1], slice[randIndex] = slice[randIndex], slice[n-1] slice = slice[:n-1] } } ","title":"Go 打乱数据排序"},{"content":"Hugo 的安装 安装可查看官方文档 安装完成后按照文档的快速启动项目操作 # 创建一个项目 hugo new site [项目名称，如：myblog] # 进入你的项目，后面所有的命令都是在项目根目录执行（未特殊标明的） cd myblog # 初始化 git 仓库 git init git remote add origin [你的 github/gitee/gitlab 仓库地址] 下载一个你喜欢的主题 官方文档 主题库 这里有很多 我使用的是这个 主题 stars 还挺多的 直接在你的项目目录执行下面 git 命令就可以了 git clone [主题仓库地址] themes/主题名 配置你的主题 项目根目录 config.toml 文件 # 设置主题 theme = \u0026#34;PaperMod\u0026#34; 具体主题相关配置可按照自己下载的主体来，如我使用的这个主体可以在他的仓库看下有 exampleSite 分支，切到这个分支下可找到 config.yml 文件 PS：如果主题的配置文件是 yml 或 yaml 格式，可以随便百度或 google yml to toml 解决配置转换问题\n创建你的内容 运行如下命令 hugo new posts/first-post.md 在 content/posts/ 里可以看到刚刚创建的 md 文件，一般内容头部（更多可以在官网查看） title: \u0026#34;使用 Hugo 搭建自己的博客\u0026#34; date: 2022-11-24T20:48:28+08:00 draft: false # 是否是草稿，构建的时候可以用上 description: \u0026#34;使用 Hugo 搭建自己的博客\u0026#34; categories: [\u0026#34;hugo\u0026#34;] # 数组，分类可以用上 tags: [\u0026#34;hugo\u0026#34;, \u0026#34;博客搭建\u0026#34;] # 数组，标签可以用上 ShowToc: true # 是否显示内容页的目录 cover: image: \u0026#34;\u0026#34; # 列表展示的图片 启动 hugo server -D # -D buildDraft 构建草稿 Start building sites … hugo v0.106.0+extended darwin/amd64 BuildDate=unknown .... .... Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 这时就可以在浏览器打开你构建出来的地址了：http://localhost:1313/ 发布 直接运行 hugo 命令，完成后可以在根目录找到 public 目录，是纯 html 格式的文件，将整个目录丢到 nginx 或其他服务器运行就可以了 hugo 附上 nginx 的 https 配置，如果不需要 https 直接去掉注释标注 https 中间部分然后监听 80 端口即可\nserver { #SSL 默认访问端口号为 443 #listen 80; listen 443 ssl; #请填写绑定证书的域名 server_name www.silent-cxl.top silent-cxl.top; ############# https ############# #请填写证书文件的相对路径或绝对路 ssl_certificate cert/silent-cxl.top.crt; #请填写私钥文件的相对路径或绝对路径 ssl_certificate_key cert/silent-cxl.top.key; ssl_session_timeout 5m; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; ############# https ############# root /usr/share/nginx/html/site/public/; index index.html index.htm; access_log /var/log/nginx/access.hugosite.log main; error_log /var/log/nginx/error.hugosite.log; location / { try_files $uri $uri/ /index.html; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } ############# https ############# server { listen 80; #请填写绑定证书的域名 server_name www.silent-cxl.top; #把http的域名请求转成https return 301 https://$host$request_uri; } ############# https ############# ","permalink":"https://www.silent-cxl.top/posts/hugo-build-blog/","summary":"Hugo 的安装 安装可查看官方文档 安装完成后按照文档的快速启动项目操作 # 创建一个项目 hugo new site [项目名称，如：myblog] # 进入你的项目，后面所有的命令都是在项目根目录执行（未特殊标明的） cd myblog # 初始化 git 仓库 git init git remote add origin [你的 github/gitee/gitlab 仓库地址] 下载一个你喜欢的主题 官方文档 主题库 这里有很多 我使用的是这个 主题 stars 还挺多的 直接在你的项目目录执行下面 git 命令就可以了 git clone [主题仓库地址] themes/主题名 配置你的主题 项目根目录 config.toml 文件 # 设置主题 theme = \u0026#34;PaperMod\u0026#34; 具体主题相关配置可按照自己下载的主体来，如我使用的这个主体可以在他的仓库看下有 exampleSite 分支，切到这个分支下可找到 config.yml 文件 PS：如果主题的配置文件是 yml 或 yaml 格式，可以随便百度或 google yml to toml 解决配置转换问题\n创建你的内容 运行如下命令 hugo new posts/first-post.","title":"使用 Hugo 搭建自己的博客"},{"content":"创建评论使用的 github 仓库 操作步骤如下图（utteranc 的操作截图） giscus 驱动与 utteranc 驱动开启操作大同小异，步骤基本相同 创建好后如我的：https://github.com/cxlcxl/comments-for-hugo，而后可在最底下的 Enable Utterances 部分取到配置 Hugo 配置文件文件修改 config.toml\n[params] # ... comments = true #使用的是 utteranc 评论，教程参考 https://utteranc.es/ [params.utteranc] enable = false repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 issueTerm = \u0026#34;pathname\u0026#34; theme = \u0026#34;github-light\u0026#34; ## 配置 giscus 评论,教程参考 https://giscus.app/zh-CN [params.giscus] enable = true repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 repoId = \u0026#34;\u0026#34; category = \u0026#34;\u0026#34; categoryId = \u0026#34;\u0026#34; mapping = \u0026#34;pathname\u0026#34; theme = \u0026#34;light_protanopia\u0026#34; lang = \u0026#34;zh-CN\u0026#34; crossorigin = \u0026#34;anonymous\u0026#34; comments.html 文件修改 文件位置：themes/PaperMod/layouts/partials/comments.html\n{{- /* Comments area start */ -}} {{- /* to add comments read =\u0026gt; https://gohugo.io/content-management/comments/ */ -}} {{ if .Site.Params.utteranc.enable }} \u0026lt;div class=\u0026#34;post bg-white\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo= \u0026#34;{{ .Site.Params.utteranc.repo }}\u0026#34; issue-term=\u0026#34;{{ .Site.Params.utteranc.issueTerm }}\u0026#34; theme=\u0026#34;{{ .Site.Params.utteranc.theme }}\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; {{ else if .Site.Params.giscus.enable }} \u0026lt;div class=\u0026#34;post bg-white\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;{{ .Site.Params.giscus.repo }}\u0026#34; data-repo-id=\u0026#34;{{ .Site.Params.giscus.repoId }}\u0026#34; data-category=\u0026#34;{{ .Site.Params.giscus.category }}\u0026#34; data-category-id=\u0026#34;{{ .Site.Params.giscus.categoryId }}\u0026#34; data-mapping=\u0026#34;{{ .Site.Params.giscus.mapping }}\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;{{ .Site.Params.giscus.theme }}\u0026#34; data-lang=\u0026#34;{{ .Site.Params.giscus.lang }}\u0026#34; crossorigin=\u0026#34;{{ .Site.Params.giscus.crossorigin }}\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{- /* Comments area end */ -}} ","permalink":"https://www.silent-cxl.top/posts/hugo-supprt-comments/","summary":"创建评论使用的 github 仓库 操作步骤如下图（utteranc 的操作截图） giscus 驱动与 utteranc 驱动开启操作大同小异，步骤基本相同 创建好后如我的：https://github.com/cxlcxl/comments-for-hugo，而后可在最底下的 Enable Utterances 部分取到配置 Hugo 配置文件文件修改 config.toml\n[params] # ... comments = true #使用的是 utteranc 评论，教程参考 https://utteranc.es/ [params.utteranc] enable = false repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 issueTerm = \u0026#34;pathname\u0026#34; theme = \u0026#34;github-light\u0026#34; ## 配置 giscus 评论,教程参考 https://giscus.app/zh-CN [params.giscus] enable = true repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 repoId = \u0026#34;\u0026#34; category = \u0026#34;\u0026#34; categoryId = \u0026#34;\u0026#34; mapping = \u0026#34;pathname\u0026#34; theme = \u0026#34;light_protanopia\u0026#34; lang = \u0026#34;zh-CN\u0026#34; crossorigin = \u0026#34;anonymous\u0026#34; comments.","title":"Hugo PaperMod 开启评论"},{"content":"创建命名空间 如果在default命名空间上可以跳过此步骤 kubectl create ns bs // 可以查看刚刚创建的 namespace kubectl get ns 创建 k8s 账号权限 创建 ads-test-auth.yaml 配置文件如下 #创建账号 apiVersion: v1 kind: ServiceAccount metadata: namespace: bs name: ads-test --- #创建角色对应操作 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: discovery-ads-test rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;endpoints\u0026#34;] # endpoints verbs: [\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;] --- #给账号绑定角色 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: find-ads-test-discovery-ads-test roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: discovery-ads-test subjects: - kind: ServiceAccount name: ads-test namespace: bs 运行 kubectl apply -f ads-test-auth.yaml 创建资源\n进入你的 go-zero 项目 API 模块 如果原配置文件的 rpc 使用的是：Endpoints，可以改成：Target 方式，示例： # .... UserRpcClient: # 原 #Endpoints: # - \u0026#34;127.0.0.1:8002\u0026#34; # 改为 结构 =\u0026gt; k8s://namespace/service:RPC 端口 Target: \u0026#34;k8s://bs/user-rpc-svc:8002\u0026#34; # .... 生成 dockerfile goctl docker -go user.go 切换到项目根路径制作镜像 docker build -f xxxxxxx/Dockerfile -t xx:xx . 可以推送到远程或本地镜像仓库方便多节点部署，本机也可以直接 docker save 之后上传 进入服务目录生成 api K8S yaml 文件 goctl kube --nodePort 30010 deploy -replicas 3 -requestCpu 100 -requestMem 50 -limitCpu 200 -limitMem 100 -name user-api -namespace bs -image user-api:v1.0 -o user-api.yaml -port 8001 --serviceAccount find-endpoints —nodePort K8S 限制端口在 30000-? 之间，不填则系统随机 RPC 模块 rpc docker 文件创建与 api 一致 进入 rpc 服务目录生成 K8S yaml 文件 goctl kube deploy -replicas 3 -requestCpu 100 -requestMem 50 -limitCpu 200 -limitMem 100 -name user-rpc -namespace bs -image user-rpc:v1.0 -o user-rpc.yaml -port 8002 --serviceAccount find-endpoints 运行生成的 k8s 文件 如果多节点且 docker 镜像没有上传镜像仓库，需要提前上传 kubectl apply -f user-rpc.yaml kubectl apply -f user-api.yaml # 检查问题与查看资源清单命令 kubectl get pod,svc,deploy -n bs # 一起查看，单个查看分开执行 kubectl describe pod [pod名] -n bs # 可以查看执行详细情况 kubectl logs [pod名] -n bs # 查看日志 等待运行完成本机就可以通过 api 的 yaml 文件定义的端口 30010 进行访问了\n","permalink":"https://www.silent-cxl.top/posts/k8s-go-zero-deploy/","summary":"创建命名空间 如果在default命名空间上可以跳过此步骤 kubectl create ns bs // 可以查看刚刚创建的 namespace kubectl get ns 创建 k8s 账号权限 创建 ads-test-auth.yaml 配置文件如下 #创建账号 apiVersion: v1 kind: ServiceAccount metadata: namespace: bs name: ads-test --- #创建角色对应操作 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: discovery-ads-test rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;endpoints\u0026#34;] # endpoints verbs: [\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;] --- #给账号绑定角色 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: find-ads-test-discovery-ads-test roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: discovery-ads-test subjects: - kind: ServiceAccount name: ads-test namespace: bs 运行 kubectl apply -f ads-test-auth.","title":"K8s 上 Go-Zero 服务本机手动部署记录"},{"content":" 匹配中间文件夹 示例 .gitignore 内容：匹配 app 下的所有模块文件夹下 config 下以 .pro.yaml 结尾的文件\n// app/user/config/databse.pro.yaml // app/goods/config/databse.pro.yaml // ... app/**/config/*.pro.yaml 忽略已被提交到远程仓库的文件 先移除本地 git 缓存 git rm --cached [要忽略的文件路径] 补充 .gitignore 文件内容即可 ","permalink":"https://www.silent-cxl.top/posts/git-ignore-use/","summary":" 匹配中间文件夹 示例 .gitignore 内容：匹配 app 下的所有模块文件夹下 config 下以 .pro.yaml 结尾的文件\n// app/user/config/databse.pro.yaml // app/goods/config/databse.pro.yaml // ... app/**/config/*.pro.yaml 忽略已被提交到远程仓库的文件 先移除本地 git 缓存 git rm --cached [要忽略的文件路径] 补充 .gitignore 文件内容即可 ","title":"Git 忽略文件使用"},{"content":" 世界上有 10 种人，懂二进制和不懂二进制的，实际上二进制只有 0 和 1，逢 2 进 1，所以 10 在二进制中并不是十进制的 10 而是十进制的 2。\n进制就是逢几进一，n 进制就是逢 n 进一。计算机只能识别二进制，人类最习惯使用的是十进制，而为了实际需要，又建立了八进制和十六进制。八进制就是逢八进一，十六进制就是逢十六进一。\n二进制转十进制 例二进制数：10010110，可转换如下\n1 0 0 1 0 1 1 0 // 二进制 1*2^7 + 0*2^6 + 0*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 0*2^0 128 + 0 + 0 + 16 + 0 + 4 + 2 + 0 = 150 // 十进制 八进制转十进制 八进制：只有 0~7，逢 8 进 1\n例八进制数：256320，可转换如下\n2 5 6 3 2 0 // 八进制 2*8^5 + 5*8^4 + 6*8^3 + 3*8^2 + 2*8^1 + 0*8^0 65536 + 20480 + 3072 + 192 + 16 + 0 = 89296 // 十进制 十六进制转十进制 十六进制稍微特殊，但是转换与上面两种相同：只有 0~9,a,b,c,d,e,f，逢 16 进 1\n例十六进制数：30af，可转换如下\n3 0 a f // 十六进制 3*16^3 + 0*16^2 + 10*16^1 + 15*16^0 12288 + 0 + 160 + 15 = 12463 // 十进制 转十进制总结：都是 位上的数字 * 进制 ^ 权重\n十进制转二进制 例十进制数：562，可如下做除非换算\n// 562 为被除数，除数为 2，直到商除为 0 停止，将余数从下往上连接既是转换结果： 2 | 562 ----- 2 | 281 ----------- 0 ----- 2 | 140 ---------- 1 ----- 2 | 70 --------- 0 ----- 2 | 35 -------- 0 ----- 2 | 17 ------- 1 ----- 2 | 8 ------ 1 ----- 2 | 4 ----- 0 ----- 2 | 2 ---- 0 ----- 2 | 1 --- 0 ----- 0 -- 1 // 结果：1000110010 十进制转八进制，十进制转十六进制同转二进制一个方式，而非十进制间的转换就可以通过十进制中转即可。\n","permalink":"https://www.silent-cxl.top/posts/computer-conversion/","summary":"世界上有 10 种人，懂二进制和不懂二进制的，实际上二进制只有 0 和 1，逢 2 进 1，所以 10 在二进制中并不是十进制的 10 而是十进制的 2。\n进制就是逢几进一，n 进制就是逢 n 进一。计算机只能识别二进制，人类最习惯使用的是十进制，而为了实际需要，又建立了八进制和十六进制。八进制就是逢八进一，十六进制就是逢十六进一。\n二进制转十进制 例二进制数：10010110，可转换如下\n1 0 0 1 0 1 1 0 // 二进制 1*2^7 + 0*2^6 + 0*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 0*2^0 128 + 0 + 0 + 16 + 0 + 4 + 2 + 0 = 150 // 十进制 八进制转十进制 八进制：只有 0~7，逢 8 进 1","title":"进制转换"},{"content":"import { defineConfig, loadEnv } from \u0026#34;vite\u0026#34; import vue from \u0026#34;@vitejs/plugin-vue\u0026#34; import path from \u0026#34;path\u0026#34; import { nodePolyfills } from \u0026#34;vite-plugin-node-polyfills\u0026#34; // https://vitejs.dev/config/ export default defineConfig(({ command, mode }) =\u0026gt; { console.log(\u0026#34;vite.config defineConfig\u0026#34;, command, mode) const env = loadEnv(mode, process.cwd(), \u0026#34;\u0026#34;) return { plugins: [ vue(), nodePolyfills({ protocolImports: true, }), ], resolve: { alias: { \u0026#34;@\u0026#34;: path.resolve(__dirname, \u0026#34;src\u0026#34;), \u0026#34;@v\u0026#34;: path.resolve(__dirname, \u0026#34;src/views\u0026#34;), \u0026#34;@a\u0026#34;: path.resolve(__dirname, \u0026#34;src/apis\u0026#34;), }, }, define: { \u0026#34;process.env\u0026#34;: env, }, server: { proxy: { \u0026#34;/api/\u0026#34;: { target: process.env.VUE_APP_BASE_API, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#34;\u0026#34;), }, }, }, } }) ","permalink":"https://www.silent-cxl.top/posts/vue-vite/","summary":"import { defineConfig, loadEnv } from \u0026#34;vite\u0026#34; import vue from \u0026#34;@vitejs/plugin-vue\u0026#34; import path from \u0026#34;path\u0026#34; import { nodePolyfills } from \u0026#34;vite-plugin-node-polyfills\u0026#34; // https://vitejs.dev/config/ export default defineConfig(({ command, mode }) =\u0026gt; { console.log(\u0026#34;vite.config defineConfig\u0026#34;, command, mode) const env = loadEnv(mode, process.cwd(), \u0026#34;\u0026#34;) return { plugins: [ vue(), nodePolyfills({ protocolImports: true, }), ], resolve: { alias: { \u0026#34;@\u0026#34;: path.resolve(__dirname, \u0026#34;src\u0026#34;), \u0026#34;@v\u0026#34;: path.resolve(__dirname, \u0026#34;src/views\u0026#34;), \u0026#34;@a\u0026#34;: path.resolve(__dirname, \u0026#34;src/apis\u0026#34;), }, }, define: { \u0026#34;process.env\u0026#34;: env, }, server: { proxy: { \u0026#34;/api/\u0026#34;: { target: process.","title":"Vue3 Vite 使用基础配置"},{"content":" Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n目录结构：\n|--public |--src ... |----store # 新建 vuex 相关文件夹 |------modules # 新建模块文件夹，存放 app.js,user.js |--------global.js |--------getters.js |--------app.js |--------user.js store 文件夹下创建 index.js import { createStore } from \u0026#34;vuex\u0026#34; import global from \u0026#34;./modules/global.js\u0026#34; import app from \u0026#34;./modules/app.js\u0026#34; // 应用基本数据 import user from \u0026#34;./modules/user.js\u0026#34; // 登录信息 import getters from \u0026#34;./modules/getters.js\u0026#34; export default createStore({ // 公共模板直接在这里展开就可以 ...global, modules: { app, user, }, getters, }) main.js 中导入 import store from \u0026#34;./store/index.js\u0026#34; createApp(App).use(store) // ... modules 文件夹下创建 app.js,user.js // user.js 内容，app.js 与 user.js 结构一致 import md5 from \u0026#34;js-md5\u0026#34; import { login, getUserInfo, logout } from \u0026#34;@a/user\u0026#34; import { setToken, getToken, delToken } from \u0026#34;@/utils/token\u0026#34; // 用户 export default { namespaced: true, state: { email: \u0026#34;\u0026#34;, username: \u0026#34;\u0026#34;, token: \u0026#34;\u0026#34;, user_id: \u0026#34;\u0026#34;, }, mutations: { setLoginInfo(state, { email, user_id, username }) { state.email = email state.user_id = user_id state.username = username }, setToken(state, { token }) { state.token = token setToken(token) }, }, actions: { login(store, { email, pass }) { return new Promise((resolve, reject) =\u0026gt; { login({ email, pass: md5(pass) }) .then((res) =\u0026gt; { const { email, token, user_id, username } = res.data store.commit(\u0026#34;setLoginInfo\u0026#34;, { email, user_id, username }) store.commit(\u0026#34;setToken\u0026#34;, { token }) resolve(res.data) }) .catch(() =\u0026gt; { reject() }) }) }, getUserInfo(store) { return new Promise((resolve, reject) =\u0026gt; { getUserInfo(getToken()) .then((res) =\u0026gt; { const { email, user_id, username } = res.data store.commit(\u0026#34;setLoginInfo\u0026#34;, { email, user_id, username }) resolve(res.data) }) .catch(() =\u0026gt; { delToken() reject() }) }) }, logout(store) { return new Promise((resolve, reject) =\u0026gt; { logout() .then(() =\u0026gt; { delToken() resolve() }) .catch(() =\u0026gt; { reject() }) }) }, }, } // getters.js 内容 export default { user_id: (state, getters) =\u0026gt; state.user.user_id, email: (state, getters) =\u0026gt; state.user.email, username: (state, getters) =\u0026gt; state.user.username, token: (state, getters) =\u0026gt; state.user.token, } // global.js 内容 export default { state: {}, mutations: {}, actions: {}, getters: {}, } vue3 页面组件中使用方式 import { useStore } from \u0026#34;vuex\u0026#34; const store = useStore() // store 就是 vuex 对象 // 例 store.dispatch(\u0026#34;user/login\u0026#34;, form).then((res) =\u0026gt; { // 成功的逻辑 // ... }).catch(() =\u0026gt; {}) ","permalink":"https://www.silent-cxl.top/posts/vue-vuex/","summary":"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n目录结构：\n|--public |--src ... |----store # 新建 vuex 相关文件夹 |------modules # 新建模块文件夹，存放 app.js,user.js |--------global.js |--------getters.js |--------app.js |--------user.js store 文件夹下创建 index.js import { createStore } from \u0026#34;vuex\u0026#34; import global from \u0026#34;./modules/global.js\u0026#34; import app from \u0026#34;./modules/app.js\u0026#34; // 应用基本数据 import user from \u0026#34;./modules/user.js\u0026#34; // 登录信息 import getters from \u0026#34;./modules/getters.js\u0026#34; export default createStore({ // 公共模板直接在这里展开就可以 ...global, modules: { app, user, }, getters, }) main.js 中导入 import store from \u0026#34;.","title":"Vue3 使用 Vuex 做登录信息"},{"content":" 直接上代码\n// intercept.js import NProgress from \u0026#34;nprogress\u0026#34; import \u0026#34;nprogress/nprogress.css\u0026#34; // progress bar style import store from \u0026#34;@/store\u0026#34; import router from \u0026#34;./router\u0026#34; import settings from \u0026#34;./settings\u0026#34; import { getToken } from \u0026#34;@/utils/token\u0026#34; import { ElMessage } from \u0026#34;element-plus\u0026#34; NProgress.configure({ showSpinner: false }) const excludeUris = [\u0026#34;/login\u0026#34;, \u0026#34;/sso/callback\u0026#34;] router.beforeEach(async (to, from, next) =\u0026gt; { NProgress.start() // 顺便设置 icon title document.title = to.meta.title ? `${to.meta.title} - ${settings.title}` : settings.title const token = getToken() if (token) { if (to.path === \u0026#34;/login\u0026#34;) { NProgress.done() next({ path: \u0026#34;/\u0026#34; }) } else { if (store.getters.user_id \u0026amp;\u0026amp; store.getters.user_id \u0026gt; 0) { next() } else { const { user_id } = await store.dispatch(\u0026#34;user/getUserInfo\u0026#34;) if (user_id \u0026gt; 0) { next({ ...to, replace: true }) } else { ElMessage.error({ message: \u0026#34;个人信息读取失败\u0026#34; }) NProgress.done() next(`/login?redirect=${to.path}`) } } } } else { NProgress.done() if (excludeUris.includes(to.path)) { next() } else { next({ path: \u0026#34;/login\u0026#34; }) } } }) router.afterEach(() =\u0026gt; { NProgress.done() }) // main.js import \u0026#34;./intercept\u0026#34; ","permalink":"https://www.silent-cxl.top/posts/vue-login-permission/","summary":"直接上代码\n// intercept.js import NProgress from \u0026#34;nprogress\u0026#34; import \u0026#34;nprogress/nprogress.css\u0026#34; // progress bar style import store from \u0026#34;@/store\u0026#34; import router from \u0026#34;./router\u0026#34; import settings from \u0026#34;./settings\u0026#34; import { getToken } from \u0026#34;@/utils/token\u0026#34; import { ElMessage } from \u0026#34;element-plus\u0026#34; NProgress.configure({ showSpinner: false }) const excludeUris = [\u0026#34;/login\u0026#34;, \u0026#34;/sso/callback\u0026#34;] router.beforeEach(async (to, from, next) =\u0026gt; { NProgress.start() // 顺便设置 icon title document.title = to.meta.title ? `${to.meta.title} - ${settings.title}` : settings.title const token = getToken() if (token) { if (to.","title":"Vue3 页面登录拦截器"},{"content":" 添加脚本文件到你期望存放的地址 #!/bin/bash SITEDIR=/www/projects/site BAKDIR=/www/baks DAYS=7 DATE=`date +%Y%m%d` REMOTE=`gitee/github/gitlab 仓库地址` # -c 压缩 # -x 解压 # -z 支持gzip解压文件 # -v 显示操作过程 # -f 使用档名，请留意，在f之后要立即接档名！不要再加参数！ tar -zcvf $BAKDIR/site-$DATE-bak.tar.gz $SITEDIR cd /www/projects/ rm -rf site git clone $REMOTE site # 删除过期备份文件 # $bakdir find 备份文件的地址 #-type f 类型为普通文件 #-mtime 7 天之前的文件 #-exec rm -f 静默删除匹配出来的文件 # 还可以 -name \u0026#34;site-*-.tar.gz\u0026#34; 名称模糊匹配 find $BAKDIR -type f -mtime +$DAYS -exec rm -f {} \\; echo \u0026#34;complete!\u0026#34; 运行 crontab -e 设置定时任务运行上一步添加的文件 ","permalink":"https://www.silent-cxl.top/posts/other-git-auto-publish/","summary":"添加脚本文件到你期望存放的地址 #!/bin/bash SITEDIR=/www/projects/site BAKDIR=/www/baks DAYS=7 DATE=`date +%Y%m%d` REMOTE=`gitee/github/gitlab 仓库地址` # -c 压缩 # -x 解压 # -z 支持gzip解压文件 # -v 显示操作过程 # -f 使用档名，请留意，在f之后要立即接档名！不要再加参数！ tar -zcvf $BAKDIR/site-$DATE-bak.tar.gz $SITEDIR cd /www/projects/ rm -rf site git clone $REMOTE site # 删除过期备份文件 # $bakdir find 备份文件的地址 #-type f 类型为普通文件 #-mtime 7 天之前的文件 #-exec rm -f 静默删除匹配出来的文件 # 还可以 -name \u0026#34;site-*-.tar.gz\u0026#34; 名称模糊匹配 find $BAKDIR -type f -mtime +$DAYS -exec rm -f {} \\; echo \u0026#34;complete!","title":"从远程仓库定时自动发版"},{"content":"遇到 go install 报错：.... dial tcp 172.217.160.113:443: i/o timeout 解决，终端执行：go env -w GOPROXY=https://goproxy.cn\n待续\u0026hellip;\n","permalink":"https://www.silent-cxl.top/posts/golang-proxy/","summary":"遇到 go install 报错：.... dial tcp 172.217.160.113:443: i/o timeout 解决，终端执行：go env -w GOPROXY=https://goproxy.cn\n待续\u0026hellip;","title":"Golang 环境搭建"},{"content":"# 从服务器上下载文件 scp [服务器用户名]@[服务器IP]:[服务器文件] [本地目录] # 上传本地文件到服务器 scp [本地文件] [服务器用户名]@[服务器IP]:[服务器目录] # 从服务器下载整个目录 scp -r [服务器用户名]@[服务器IP]:[服务器目录] [本地目录] # 上传目录到服务器 scp -r [本地目录] [服务器用户名]@[服务器IP]:[服务器目录] # 如果用到非 22 端口则在 scp 后使用 -P 参数 ","permalink":"https://www.silent-cxl.top/posts/linux-scp/","summary":"# 从服务器上下载文件 scp [服务器用户名]@[服务器IP]:[服务器文件] [本地目录] # 上传本地文件到服务器 scp [本地文件] [服务器用户名]@[服务器IP]:[服务器目录] # 从服务器下载整个目录 scp -r [服务器用户名]@[服务器IP]:[服务器目录] [本地目录] # 上传目录到服务器 scp -r [本地目录] [服务器用户名]@[服务器IP]:[服务器目录] # 如果用到非 22 端口则在 scp 后使用 -P 参数 ","title":"Linux scp 文件管理"},{"content":" 虚拟机版本：CentOS Linux release 7.9.2009 (Core)\n配置文件地址：/etc/sysconfig/network-scripts/ifcfg-enp0s3\nTYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPADDR=192.168.120.61 IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=enp0s3 UUID=03dae35b-d264-45e4-8d73-8920ab61cd02 DEVICE=enp0s3 ONBOOT=yes GETRWAY=192.168.56.1 NETMASK=255.255.255.0 DNS1=192.168.56.1 ","permalink":"https://www.silent-cxl.top/posts/virtual-network/","summary":" 虚拟机版本：CentOS Linux release 7.9.2009 (Core)\n配置文件地址：/etc/sysconfig/network-scripts/ifcfg-enp0s3\nTYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPADDR=192.168.120.61 IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=enp0s3 UUID=03dae35b-d264-45e4-8d73-8920ab61cd02 DEVICE=enp0s3 ONBOOT=yes GETRWAY=192.168.56.1 NETMASK=255.255.255.0 DNS1=192.168.56.1 ","title":"Virtual 本地虚拟机网络配置"},{"content":"解决方式：\n无需设置 default-checked-keys 属性\n读取到接口数据后使用 this.$refs.tree.setCheckedNodes(***传入接口返回的节点 keys***) 设置默认； 提交前使用 this.$refs.tree.getCheckedKeys() 再次获取选中的节点并赋值 ","permalink":"https://www.silent-cxl.top/posts/vue-element-tree-checked-bug/","summary":"解决方式：\n无需设置 default-checked-keys 属性\n读取到接口数据后使用 this.$refs.tree.setCheckedNodes(***传入接口返回的节点 keys***) 设置默认； 提交前使用 this.$refs.tree.getCheckedKeys() 再次获取选中的节点并赋值 ","title":"Vue el-tree 的 default-checked-keys 属性默认选中状态bug问题"},{"content":"查看根分区大小 df -h\n文件系统 类型 容量 已用 可用 已用% 挂载点 /dev/mapper/centos-root xfs 18G 1.1G 17G 6% / devtmpfs devtmpfs 479M 0 479M 0% /dev tmpfs tmpfs 489M 0 489M 0% /dev/shm tmpfs tmpfs 489M 6.7M 483M 2% /run tmpfs tmpfs 489M 0 489M 0% /sys/fs/cgroup /dev/sda1 xfs 497M 125M 373M 25% /boot tmpfs tmpfs 98M 0 98M 0% /run/user/0 在虚拟机中添加一块物理的磁盘，重起虚拟机 查看磁盘编号 ls /dev/sd*\n/dev/sda /dev/sda1 /dev/sda2 /dev/sdb 创建pv pvcreate /dev/sdb\nPhysical volume \u0026#34;/dev/sdb\u0026#34; successfully created 把 pv 加入 vg 中，相当于扩充 vg 的大小 先使用 vgs 查看 vg 组 vgs\nVG #PV #LV #SN Attr VSize VFree centos 2 2 0 wz--n- 59.50g 20.04g 扩展 vg，使用 vgextend 命令 vgextend centos /dev/sdb\n把 vg 卷扩展了，在用 vgs 查看一下 vgs\nVG #PV #LV #SN Attr VSize VFree centos 2 2 0 wz--n- 39.50g 20.04g lvs\nLV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root centos -wi-ao---- 17.47g swap centos -wi-ao---- 2.00g 虽然我们把vg扩展了，但是lv还没有扩展 扩展 lv，使用 lvextend 命令 lvextend -L +20G /dev/mapper/centos-root\nSize of logical volume centos/root changed from 17.47 GiB (4472 extents) to 37.47 GiB (9592 extents). Logical volume root successfully resized 命令使系统重新读取大小 xfs_growfs /dev/mapper/centos-root\nmeta-data=/dev/mapper/centos-root isize=256 agcount=4, agsize=1144832 blks = sectsz=512 attr=2, projid32bit=1 = crc=0 finobt=0 data = bsize=4096 blocks=4579328, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=0 log =internal bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =none extsz=4096 blocks=0, rtextents=0 data blocks changed from 4579328 to 9822208 再使用 df -h 查看 df -h\n文件系统 容量 已用 可用 已用% 挂载点 /dev/mapper/centos-root 38G 1.1G 37G 3% / devtmpfs 479M 0 479M 0% /dev tmpfs 489M 0 489M 0% /dev/shm tmpfs 489M 6.7M 483M 2% /run tmpfs 489M 0 489M 0% /sys/fs/cgroup /dev/sda1 497M 125M 373M 25% /boot tmpfs 98M 0 98M 0% /run/user/0 转载自：虚拟机扩容（/dev/mapper/centos-root 空间不足）\n","permalink":"https://www.silent-cxl.top/posts/virtual-space-not-enough/","summary":"查看根分区大小 df -h\n文件系统 类型 容量 已用 可用 已用% 挂载点 /dev/mapper/centos-root xfs 18G 1.1G 17G 6% / devtmpfs devtmpfs 479M 0 479M 0% /dev tmpfs tmpfs 489M 0 489M 0% /dev/shm tmpfs tmpfs 489M 6.7M 483M 2% /run tmpfs tmpfs 489M 0 489M 0% /sys/fs/cgroup /dev/sda1 xfs 497M 125M 373M 25% /boot tmpfs tmpfs 98M 0 98M 0% /run/user/0 在虚拟机中添加一块物理的磁盘，重起虚拟机 查看磁盘编号 ls /dev/sd*\n/dev/sda /dev/sda1 /dev/sda2 /dev/sdb 创建pv pvcreate /dev/sdb","title":"Virtual 虚拟机扩容（/dev/mapper/centos-root 空间不足）"},{"content":"git bash 进入项目目录：\ngit config --global credential.helper store 输入以上命令后，重新拉取代码再次输入账号密码，输入后会记住，以后拉代码不需要再输入。\n","permalink":"https://www.silent-cxl.top/posts/git-pull-repeat-enter-pass/","summary":"git bash 进入项目目录：\ngit config --global credential.helper store 输入以上命令后，重新拉取代码再次输入账号密码，输入后会记住，以后拉代码不需要再输入。","title":"Git 解决每次 git pull 需要输入账号密码"},{"content":" 你好！我是 silent，中文名：程晓良，很高兴你能进入我的博客，如有互相交流的可添加微信：Silent-Cxl（备注：技术交流）。\n关于我 我是一名从服务行业转行的 PHP/Golang 开发，会点前端技能，能用 vue、jQuery 等前端框架。\n13 年毕业的我在酒店里做服务员，经过几年的努力并没有什么出路，17年毅然准备转行，但是却并没有头绪，恰巧碰上技术开发岗位的招聘，果断选择尝试，然而没有成功入职，却交了智商费用 500，而后自学了前端到深圳干了一年前端开发，再通过自学 PHP 转到了后端开发，21 年了解到了 golang 的火爆又开始转到了 golang，如今在深圳一家上市公司担任开发。\n","permalink":"https://www.silent-cxl.top/about/","summary":"你好！我是 silent，中文名：程晓良，很高兴你能进入我的博客，如有互相交流的可添加微信：Silent-Cxl（备注：技术交流）。\n关于我 我是一名从服务行业转行的 PHP/Golang 开发，会点前端技能，能用 vue、jQuery 等前端框架。\n13 年毕业的我在酒店里做服务员，经过几年的努力并没有什么出路，17年毅然准备转行，但是却并没有头绪，恰巧碰上技术开发岗位的招聘，果断选择尝试，然而没有成功入职，却交了智商费用 500，而后自学了前端到深圳干了一年前端开发，再通过自学 PHP 转到了后端开发，21 年了解到了 golang 的火爆又开始转到了 golang，如今在深圳一家上市公司担任开发。","title":"关于 Silent"},{"content":" 首先安装 air 运行命令：go install github.com/cosmtrek/air@latest 项目根目录创建 air 配置文件：.air.conf # .air.conf 文件内容 root = \u0026#34;.\u0026#34; tmp_dir = \u0026#34;tmp\u0026#34; [build] # Just plain old shell command. You could use `make` as well. cmd = \u0026#34;go build -o ./tmp/main ./web/main.go\u0026#34; # Binary file yields from `cmd`. bin = \u0026#34;tmp/main\u0026#34; # Customize binary. full_bin = \u0026#34;APP_ENV=dev APP_USER=air ./tmp/main\u0026#34; # Watch these filename extensions. include_ext = [\u0026#34;go\u0026#34;, \u0026#34;tpl\u0026#34;, \u0026#34;tmpl\u0026#34;, \u0026#34;html\u0026#34;] # Ignore these filename extensions or directories. exclude_dir = [\u0026#34;storage\u0026#34;, \u0026#34;web/storage\u0026#34;] # Watch these directories if you specified. include_dir = [] # Exclude files. exclude_file = [] # This log file places in your tmp_dir. log = \u0026#34;air.log\u0026#34; # It\u0026#39;s not necessary to trigger build each time file changes if it\u0026#39;s too frequent. delay = 1000 # ms # Stop running old binary when build errors occur. stop_on_error = true # Send Interrupt signal before killing process (windows does not support this feature) send_interrupt = false # Delay after sending Interrupt signal kill_delay = 500 # ms [log] # Show log time time = false [color] # Customize each part\u0026#39;s color. If no color found, use the raw app log. main = \u0026#34;magenta\u0026#34; watcher = \u0026#34;cyan\u0026#34; build = \u0026#34;yellow\u0026#34; runner = \u0026#34;green\u0026#34; [misc] # Delete tmp directory on exit clean_on_exit = true 运行命令：air 或 air -d ","permalink":"https://www.silent-cxl.top/posts/golang-air/","summary":"首先安装 air 运行命令：go install github.com/cosmtrek/air@latest 项目根目录创建 air 配置文件：.air.conf # .air.conf 文件内容 root = \u0026#34;.\u0026#34; tmp_dir = \u0026#34;tmp\u0026#34; [build] # Just plain old shell command. You could use `make` as well. cmd = \u0026#34;go build -o ./tmp/main ./web/main.go\u0026#34; # Binary file yields from `cmd`. bin = \u0026#34;tmp/main\u0026#34; # Customize binary. full_bin = \u0026#34;APP_ENV=dev APP_USER=air ./tmp/main\u0026#34; # Watch these filename extensions. include_ext = [\u0026#34;go\u0026#34;, \u0026#34;tpl\u0026#34;, \u0026#34;tmpl\u0026#34;, \u0026#34;html\u0026#34;] # Ignore these filename extensions or directories.","title":"golang air 热更新使用"},{"content":"编写 proto 文件 // role.proto 文件 syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;./marketing\u0026#34;; package marketing; message RoleCreateReq { string role_name = 1; } // user.proto 文件 syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;./rbac\u0026#34;; package rbac; import \u0026#34;pb/role.proto\u0026#34;; // 以执行 goctl 命令为起始路径 message UserCreateReq { string username = 1; string email = 2; } message BaseResp { int64 code = 1; } service RbacCenter{ // RPC 服务 rpc RoleCreate(RoleCreateReq) returns(BaseResp); rpc UserCreate(UserCreateReq) returns(BaseResp); } 两个文件放在同一目录内\n执行 goctl 与 原始 protoc 命令 goctl rpc protoc ./pb/user.proto --go_out=. --go-grpc_out=. --zrpc_out=. -style goZero # 生成代码 protoc ./pb/role.proto --go_out=. --go-grpc_out=. # 生成 pb.go 数据结构文件 进入 rbaccenter 目录映射一下 type 数据类型\n","permalink":"https://www.silent-cxl.top/posts/gozero-import-other-proto/","summary":"编写 proto 文件 // role.proto 文件 syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;./marketing\u0026#34;; package marketing; message RoleCreateReq { string role_name = 1; } // user.proto 文件 syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;./rbac\u0026#34;; package rbac; import \u0026#34;pb/role.proto\u0026#34;; // 以执行 goctl 命令为起始路径 message UserCreateReq { string username = 1; string email = 2; } message BaseResp { int64 code = 1; } service RbacCenter{ // RPC 服务 rpc RoleCreate(RoleCreateReq) returns(BaseResp); rpc UserCreate(UserCreateReq) returns(BaseResp); } 两个文件放在同一目录内","title":"go-zero goctl 使用 proto 引入其他 proto 文件"},{"content":"资源清单格式 apiVersion: group/apiversion # 如果没有给定 group 名称，那么默认为 core，可以使用 kubectl api-versions # 获取当前 k8s 版本上所有的 apiVersion 版本信息( 每个版本可能不同 ) kind: #资源类别 metadata： #资源元数据 name namespace lables annotations # 主要目的是方便用户阅读查找 spec: # 期望的状态（disired state） status：# 当前状态，本字段有 Kubernetes 自身维护，用户不能去定义 资源清单的常用命令 获取 apiversion 版本信息\n[root@k8s-master01 ~]# kubectl api-versions admissionregistration.k8s.io/v1beta1 apiextensions.k8s.io/v1beta1 apiregistration.k8s.io/v1 apiregistration.k8s.io/v1beta1 apps/v1 ......(以下省略) 获取资源的 apiVersion 版本信息\n[root@k8s-master01 ~]# kubectl explain pod KIND: Pod VERSION: v1 .....(以下省略) [root@k8s-master01 ~]# kubectl explain Ingress KIND: Ingress VERSION: extensions/v1beta1 获取字段设置帮助文档\n[root@k8s-master01 ~]# kubectl explain pod KIND: Pod VERSION: v1 DESCRIPTION: Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. FIELDS: apiVersion \u0026lt;string\u0026gt; ........ ........ 字段配置格式\napiVersion \u0026lt;string\u0026gt; #表示字符串类型 metadata \u0026lt;Object\u0026gt; #表示需要嵌套多层字段 labels \u0026lt;map[string]string\u0026gt; #表示由k:v组成的映射 finalizers \u0026lt;[]string\u0026gt; #表示字串列表 ownerReferences \u0026lt;[]Object\u0026gt; #表示对象列表 hostPID \u0026lt;boolean\u0026gt; #布尔类型 priority \u0026lt;integer\u0026gt; #整型 name \u0026lt;string\u0026gt; -required- #如果类型后面接 -required-，表示为必填字段 通过定义清单文件创建 Pod apiVersion: v1 # 根绝对象类型可以查询 kubectl explain pod 取 version 的值 kind: Pod # 对象类型先确定 metadata: name: pod-demo namespace: default labels: app: myapp spec: containers: - name: myapp-1 image: harbor.hongfu.com/library/myapp:v1 - name: busybox-1 image: harbor.hongfu.com/library/busybox:v1 command: # 替换镜像默认封装的命令 - \u0026#34;/bin/sh\u0026#34; - \u0026#34;-c\u0026#34; - \u0026#34;sleep 3600\u0026#34; kubectl get pod xx.xx.xx -o yaml \u0026lt;!--使用 -o 参数 加 yaml，可以将资源的配置以 yaml的格式输出出来，也可以使用json，输出为json格式--\u0026gt; kubectl create -f [yaml-filename] # 创建资源 kubectl explain pod # 获取 kind 所属的 apiVersion # 读取子对象配置 kubectl explain pod.metadata kubectl get pod -n kube-system [pod-name] -o yaml # 查看某个 pod yaml 配置清单 -n 名称控件，默认 default -o wide kubectl exec -it [pod-name] -c [container-name] # 进入某个 pod 的容器 kubectl logs [pod-name] kubectl describe pod [pod-name] kubectl delete [pod | svc] [--all | pod-name] # 删除 pod、service ","permalink":"https://www.silent-cxl.top/posts/k8s-3-list/","summary":"资源清单格式 apiVersion: group/apiversion # 如果没有给定 group 名称，那么默认为 core，可以使用 kubectl api-versions # 获取当前 k8s 版本上所有的 apiVersion 版本信息( 每个版本可能不同 ) kind: #资源类别 metadata： #资源元数据 name namespace lables annotations # 主要目的是方便用户阅读查找 spec: # 期望的状态（disired state） status：# 当前状态，本字段有 Kubernetes 自身维护，用户不能去定义 资源清单的常用命令 获取 apiversion 版本信息\n[root@k8s-master01 ~]# kubectl api-versions admissionregistration.k8s.io/v1beta1 apiextensions.k8s.io/v1beta1 apiregistration.k8s.io/v1 apiregistration.k8s.io/v1beta1 apps/v1 ......(以下省略) 获取资源的 apiVersion 版本信息\n[root@k8s-master01 ~]# kubectl explain pod KIND: Pod VERSION: v1 .....(以下省略) [root@k8s-master01 ~]# kubectl explain Ingress KIND: Ingress VERSION: extensions/v1beta1 获取字段设置帮助文档","title":"K8s - 资源清单"},{"content":"kube-proxy开启ipvs的前置条件 modprobe br_netfilter cat \u0026gt; /etc/sysconfig/modules/ipvs.modules \u0026lt;\u0026lt;EOF #!/bin/bash modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 EOF chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; bash /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4 如果报错：modprobe: FATAL: Module nf_conntrack_ipv4 not found. 内核高版本的 nf_conntrack_ipv4 已被 nf_conntrack 替换，将以上的 nf_conntrack_ipv4 改为 nf_conntrack 重新执行。\n安装 Docker 软件 yum install -y yum-utils device-mapper-persistent-data lvm2 # docker 依赖包 # docker 镜像源 yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum install -y docker-ce ## 创建 /etc/docker 目录 mkdir /etc/docker # 配置 daemon. cat \u0026gt; /etc/docker/daemon.json \u0026lt;\u0026lt;EOF { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;insecure-registries\u0026#34;: [\u0026#34;harbor.hongfu.com\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;--阿里云镜像加速地址--\u0026#34; ] } EOF mkdir -p /etc/systemd/system/docker.service.d # 重启docker服务 systemctl daemon-reload \u0026amp;\u0026amp; systemctl restart docker \u0026amp;\u0026amp; systemctl enable docker 安装 Kubeadm （主从配置） cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF yum -y install kubeadm-1.15.1 kubectl-1.15.1 kubelet-1.15.1 systemctl enable kubelet.service 导入 k8s 镜像，有梯子可以直接下载：kubeadm config images pull\nv1.15.1 版本的镜像网盘下载地址如下： 链接: https://pan.baidu.com/s/1aAHyZXVjHr0Wclh6xFJV2w 提取码: b269\n# 8s.gcr.io/kube-apiserver # 8s.gcr.io/kube-proxy # 8s.gcr.io/kube-scheduler # 8s.gcr.io/kube-controller-manager # 8s.gcr.io/etcd # 8s.gcr.io/pause # 8s.gcr.io/coredns/coredns docker save [-o | \u0026gt;] 保存的镜像名.tar [镜像名:tag | 镜像ID] # 如果以镜像ID导出，导入时需要自己重新修改镜像名称和 tag docker load [-i | \u0026lt;] 保存的镜像名.tar docker tag 镜像ID 镜像名:镜像tag 初始化主节点 kubeadm config print init-defaults \u0026gt; kubeadm-config.yaml # 打印一个初始化配置到 kubeadm-config.yaml 文件 # 调整刚刚打印出来的 kubeadm-config.yaml 文件修改点如下： localAPIEndpoint: advertiseAddress: 192.168.66.10 # 本机IP kubernetesVersion: v1.15.1 networking: podSubnet: \u0026#34;10.244.0.0/16\u0026#34; # flannel 要求网段 serviceSubnet: 10.96.0.0/12 --- apiVersion: kubeproxy.config.k8s.io/v1alpha1 kind: KubeProxyConfiguration featureGates: SupportIPVSProxyMode: true mode: ipvs kubeadm init --config=kubeadm-config.yaml --experimental-upload-certs | tee kubeadm-init.log 安装日志\nFlag --experimental-upload-certs has been deprecated, use --upload-certs instead W0719 15:03:54.748649 7060 strict.go:54] error unmarshaling configuration schema.GroupVersionKind{Group:\u0026#34;kubeadm.k8s.io\u0026#34;, Version:\u0026#34;v1beta2\u0026#34;, Kind:\u0026#34;InitConfiguration\u0026#34;}: error unmarshaling JSON: while decoding JSON: json: unknown field \u0026#34;kubernetesVersion\u0026#34; [init] Using Kubernetes version: v1.15.1 [preflight] Running pre-flight checks [WARNING IsDockerSystemdCheck]: detected \u0026#34;cgroupfs\u0026#34; as the Docker cgroup driver. The recommended driver is \u0026#34;systemd\u0026#34;. Please follow the guide at https://kubernetes.io/docs/setup/cri/ [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 20.10.10. Latest validated version: 18.09 [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using \u0026#39;kubeadm config images pull\u0026#39; [kubelet-start] Writing kubelet environment file with flags to file \u0026#34;/var/lib/kubelet/kubeadm-flags.env\u0026#34; [kubelet-start] Writing kubelet configuration to file \u0026#34;/var/lib/kubelet/config.yaml\u0026#34; [kubelet-start] Activating the kubelet service [certs] Using certificateDir folder \u0026#34;/etc/kubernetes/pki\u0026#34; [certs] Generating \u0026#34;front-proxy-ca\u0026#34; certificate and key [certs] Generating \u0026#34;front-proxy-client\u0026#34; certificate and key [certs] Generating \u0026#34;etcd/ca\u0026#34; certificate and key [certs] Generating \u0026#34;etcd/server\u0026#34; certificate and key [certs] etcd/server serving cert is signed for DNS names [master-1 localhost] and IPs [192.168.0.101 127.0.0.1 ::1] [certs] Generating \u0026#34;etcd/peer\u0026#34; certificate and key [certs] etcd/peer serving cert is signed for DNS names [master-1 localhost] and IPs [192.168.0.101 127.0.0.1 ::1] [certs] Generating \u0026#34;etcd/healthcheck-client\u0026#34; certificate and key [certs] Generating \u0026#34;apiserver-etcd-client\u0026#34; certificate and key [certs] Generating \u0026#34;ca\u0026#34; certificate and key [certs] Generating \u0026#34;apiserver\u0026#34; certificate and key [certs] apiserver serving cert is signed for DNS names [master-1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.0.101] [certs] Generating \u0026#34;apiserver-kubelet-client\u0026#34; certificate and key [certs] Generating \u0026#34;sa\u0026#34; key and public key [kubeconfig] Using kubeconfig folder \u0026#34;/etc/kubernetes\u0026#34; [kubeconfig] Writing \u0026#34;admin.conf\u0026#34; kubeconfig file [kubeconfig] Writing \u0026#34;kubelet.conf\u0026#34; kubeconfig file [kubeconfig] Writing \u0026#34;controller-manager.conf\u0026#34; kubeconfig file [kubeconfig] Writing \u0026#34;scheduler.conf\u0026#34; kubeconfig file [control-plane] Using manifest folder \u0026#34;/etc/kubernetes/manifests\u0026#34; [control-plane] Creating static Pod manifest for \u0026#34;kube-apiserver\u0026#34; [control-plane] Creating static Pod manifest for \u0026#34;kube-controller-manager\u0026#34; [control-plane] Creating static Pod manifest for \u0026#34;kube-scheduler\u0026#34; [etcd] Creating static Pod manifest for local etcd in \u0026#34;/etc/kubernetes/manifests\u0026#34; [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \u0026#34;/etc/kubernetes/manifests\u0026#34;. This can take up to 4m0s [kubelet-check] Initial timeout of 40s passed. [apiclient] All control plane components are healthy after 40.503426 seconds [upload-config] Storing the configuration used in ConfigMap \u0026#34;kubeadm-config\u0026#34; in the \u0026#34;kube-system\u0026#34; Namespace [kubelet] Creating a ConfigMap \u0026#34;kubelet-config-1.15\u0026#34; in namespace kube-system with the configuration for the kubelets in the cluster [upload-certs] Storing the certificates in Secret \u0026#34;kubeadm-certs\u0026#34; in the \u0026#34;kube-system\u0026#34; Namespace [upload-certs] Using certificate key: df949aae79dfa71766351e9ca59deaf1dfcee045d46121d037881d42ddcbcf06 [mark-control-plane] Marking the node master-1 as control-plane by adding the label \u0026#34;node-role.kubernetes.io/master=\u0026#39;\u0026#39;\u0026#34; [mark-control-plane] Marking the node master-1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule] [bootstrap-token] Using token: abcdef.0123456789abcdef [bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles [bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials [bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token [bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster [bootstrap-token] Creating the \u0026#34;cluster-info\u0026#34; ConfigMap in the \u0026#34;kube-public\u0026#34; namespace [addons] Applied essential addon: CoreDNS [addons] Applied essential addon: kube-proxy Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.0.101:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:39a62e1abd02ce75c82b39cb81798446266316fbc16ebd286049116184c82287 如果报错：unknown flag: --experimental-upload-certs 可能是版本升级的原因，将以上的 --experimental-upload-certs 改为 --upload-certs 重新执行。\n加入主节点以及其余工作节点 执行安装日志中的加入命令即可 使用 flannel 部署 k8s 的扁平化网络 首先需要下载 flannel 的 docker 镜像：quay.io/coreos/flannel:v0.12.0-amd64 flannel 镜像与配置文件地址如下： 链接: https://pan.baidu.com/s/13g41uMWuQEu-CSpfhWmTTA 提取码: a2nn\n# -f 后为配置文件，如已下载可直接指向下载了的文件 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 附加：已启动的 master 查寻 token 和 hash 值加入\n# 查询 token kubeadm token list # 查询 hash 值 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u0026gt;/dev/null | openssl dgst -sha256 -hex | sed \u0026#39;s/^.* //\u0026#39; ","permalink":"https://www.silent-cxl.top/posts/k8s-2-install/","summary":"kube-proxy开启ipvs的前置条件 modprobe br_netfilter cat \u0026gt; /etc/sysconfig/modules/ipvs.modules \u0026lt;\u0026lt;EOF #!/bin/bash modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 EOF chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; bash /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4 如果报错：modprobe: FATAL: Module nf_conntrack_ipv4 not found. 内核高版本的 nf_conntrack_ipv4 已被 nf_conntrack 替换，将以上的 nf_conntrack_ipv4 改为 nf_conntrack 重新执行。\n安装 Docker 软件 yum install -y yum-utils device-mapper-persistent-data lvm2 # docker 依赖包 # docker 镜像源 yum-config-manager \\ --add-repo \\ http://mirrors.","title":"K8s - Kubeadm 部署安装"},{"content":"设置系统主机名 hostnamectl set-hostname k8s-master01 安装依赖包 yum install -y conntrack ntpdate ntp ipvsadm ipset iptables curl sysstat libseccomp wget vim net-tools git 设置 Iptables systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld yum -y install iptables-services \u0026amp;\u0026amp; systemctl start iptables \u0026amp;\u0026amp; systemctl enable iptables \u0026amp;\u0026amp; iptables -F \u0026amp;\u0026amp; service iptables save 关闭 SELINUX swapoff -a \u0026amp;\u0026amp; sed -i \u0026#39;/ swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab setenforce 0 \u0026amp;\u0026amp; sed -i \u0026#39;s/^SELINUX=.*/SELINUX=disabled/\u0026#39; /etc/selinux/config 调整内核参数 cat \u0026gt; kubernetes.conf \u0026lt;\u0026lt;EOF net.bridge.bridge-nf-call-iptables=1 # ipv4 的情况下所有经过网桥的网络必需经过 iptables 处理 net.bridge.bridge-nf-call-ip6tables=1 # ipv6 的情况下所有经过网桥的网络必需经过 iptables 处理 net.ipv4.ip_forward=1 #数据包转发 net.ipv4.tcp_tw_recycle=0 vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它 vm.overcommit_memory=1 # 不检查物理内存是否够用 vm.panic_on_oom=0 # 开启 OOM\tfs.inotify.max_user_instances=8192 fs.inotify.max_user_watches=1048576 fs.file-max=52706963 fs.nr_open=52706963 net.ipv6.conf.all.disable_ipv6=1 net.netfilter.nf_conntrack_max=2310720 EOF cp kubernetes.conf /etc/sysctl.d/kubernetes.conf sysctl -p /etc/sysctl.d/kubernetes.conf 调整系统时区 # 设置系统时区为 中国/上海 timedatectl set-timezone Asia/Shanghai # 将当前的 UTC 时间写入硬件时钟 timedatectl set-local-rtc 0 # 重启依赖于系统时间的服务 systemctl restart rsyslog systemctl restart crond 关闭系统不需要服务 systemctl stop postfix \u0026amp;\u0026amp; systemctl disable postfix 设置日志 mkdir /var/log/journal # 持久化保存日志的目录 mkdir /etc/systemd/journald.conf.d cat \u0026gt; /etc/systemd/journald.conf.d/99-prophet.conf \u0026lt;\u0026lt;EOF [Journal] # 持久化保存到磁盘 Storage=persistent # 压缩历史日志 Compress=yes SyncIntervalSec=5m RateLimitInterval=30s RateLimitBurst=1000 # 最大占用空间 10G SystemMaxUse=10G # 单日志文件最大 200M SystemMaxFileSize=200M # 日志保存时间 2 周 MaxRetentionSec=2week # 不将日志转发到 syslog ForwardToSyslog=no EOF systemctl restart systemd-journald 升级系统内核为 4.44 CentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定，例如： rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\nrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm # 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！ yum --enablerepo=elrepo-kernel install -y kernel-lt # 设置开机从新内核启动 grub2-set-default \u0026#39;CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)\u0026#39; ","permalink":"https://www.silent-cxl.top/posts/k8s-1-init/","summary":"设置系统主机名 hostnamectl set-hostname k8s-master01 安装依赖包 yum install -y conntrack ntpdate ntp ipvsadm ipset iptables curl sysstat libseccomp wget vim net-tools git 设置 Iptables systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld yum -y install iptables-services \u0026amp;\u0026amp; systemctl start iptables \u0026amp;\u0026amp; systemctl enable iptables \u0026amp;\u0026amp; iptables -F \u0026amp;\u0026amp; service iptables save 关闭 SELINUX swapoff -a \u0026amp;\u0026amp; sed -i \u0026#39;/ swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab setenforce 0 \u0026amp;\u0026amp; sed -i \u0026#39;s/^SELINUX=.*/SELINUX=disabled/\u0026#39; /etc/selinux/config 调整内核参数 cat \u0026gt; kubernetes.","title":"K8s - 系统初始化"}]