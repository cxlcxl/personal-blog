[{"content":"Centos 安装 Docker 本机通过 Virtualbox 安装 Centos 虚拟机（需自行安装）后，安装 Docker： 如果安装使用的非 root 账号，需要加 sudo\n卸载旧版本，如未安装过旧版本可不执行 1yum remove docker \\ 2 docker-client \\ 3 docker-client-latest \\ 4 docker-common \\ 5 docker-latest \\ 6 docker-latest-logrotate \\ 7 docker-logrotate \\ 8 docker-selinux \\ 9 docker-engine-selinux \\ 10 docker-engine 安装依赖包 1yum install -y yum-utils 添加 yum 软件源（不建议使用官方 Docker 安装源，下载很慢） 1yum-config-manager \\ 2 --add-repo \\ 3 https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 4 5 6sed -i \u0026#39;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g\u0026#39; /etc/yum.repos.d/docker-ce.repo 安装 Docker 引擎 1yum install docker-ce docker-ce-cli containerd.io 启动 Docker 并将 Docker 设置为开机自启 1systemctl start docker 2 3systemctl enable docker 4 5docker version 另外通过 docker-compose 搭建本地环境，需再另外安装 docker-compose 插件 1curl -L https://download.fastgit.org/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose 2 3sudo chmod +x /usr/local/bin/docker-compose 4 5docker-compose version 配置 docker 镜像加速 1// 文件地址 /etc/docker/daemon.json 2{ 3 \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], 4 \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, 5 \u0026#34;log-opts\u0026#34;: { 6 // 限制 docker 日志的配置 7 \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;10\u0026#34; 8 }, 9 \u0026#34;insecure-registries\u0026#34;: [\u0026#34;harbor.hongfu.com\u0026#34;], 10 \u0026#34;registry-mirrors\u0026#34;: [ 11 \u0026#34;可使用阿里云镜像加速地址\u0026#34; 12 ] 13} 1systemctl daemon-reload \u0026amp;\u0026amp; systemctl restart docker 阿里云镜像加速地址获取方式：\n登陆阿里云控制台 -\u0026gt; 搜索 “容器镜像服务” -\u0026gt; 镜像工具 -\u0026gt; 镜像加速器\n","permalink":"https://www.silent-cxl.top/posts/centos-docker-install/","summary":"Centos 安装 Docker 本机通过 Virtualbox 安装 Centos 虚拟机（需自行安装）后，安装 Docker： 如果安装使用的非 root 账号，需要加 sudo\n卸载旧版本，如未安装过旧版本可不执行 1yum remove docker \\ 2 docker-client \\ 3 docker-client-latest \\ 4 docker-common \\ 5 docker-latest \\ 6 docker-latest-logrotate \\ 7 docker-logrotate \\ 8 docker-selinux \\ 9 docker-engine-selinux \\ 10 docker-engine 安装依赖包 1yum install -y yum-utils 添加 yum 软件源（不建议使用官方 Docker 安装源，下载很慢） 1yum-config-manager \\ 2 --add-repo \\ 3 https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 4 5 6sed -i \u0026#39;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g\u0026#39; /etc/yum.repos.d/docker-ce.repo 安装 Docker 引擎 1yum install docker-ce docker-ce-cli containerd.","title":"Centos 安装 docker"},{"content":"为什么要使用虚拟机来搭建开发环境 对于新手即可以熟悉 Linux 使用，同时也可以减少或避免在 windows 系统上安装服务时出现的奇葩问题 还可以与测试正式服务器统一运行环境，减少开发时出现的“在我这都不会”问题 反正有很多好处就行了 软件准备 VirtualBox 本人版本 6.1 需要 6.1 版本的可以点此下载：\nCentos 本人版本 7.9「CentOS-7-x86_64-Minimal-2207-02.iso」\n","permalink":"https://www.silent-cxl.top/posts/virtual/","summary":"为什么要使用虚拟机来搭建开发环境 对于新手即可以熟悉 Linux 使用，同时也可以减少或避免在 windows 系统上安装服务时出现的奇葩问题 还可以与测试正式服务器统一运行环境，减少开发时出现的“在我这都不会”问题 反正有很多好处就行了 软件准备 VirtualBox 本人版本 6.1 需要 6.1 版本的可以点此下载：\nCentos 本人版本 7.9「CentOS-7-x86_64-Minimal-2207-02.iso」","title":"Virtual 虚拟机安装 Centos7"},{"content":"","permalink":"https://www.silent-cxl.top/review/redis-cache/","summary":"","title":"Redis Cache"},{"content":" 1-- 前面 4 步是操作分区的字段（设置为主键 PRIMARY），如果要分区的字段已是主键可跳过这几步 2 3-- 1. 移除 id 的自增 4alter table [tablename] modify id bigint(20)unsigned; 5 6-- 2. 移除主键 7alter table [tablename] drop PRIMARY KEY; 8 9-- 3. 重新添加主键 10alter table [tablename] add PRIMARY KEY(id,stat_day); 11 12-- 4. 重新设置 id 自增 13alter table [tablename] modify id bigint(20)unsigned AUTO_INCREMENT; 14 15-- 5. 正式分区语句 16ALTER TABLE [tablename] PARTITION BY RANGE (TO_DAYS(stat_day)) ( 17 PARTITION p20231 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-01-01\u0026#39;)), -- TO_DAYS(\u0026#39;20230101\u0026#39;) 18 PARTITION p20232 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-02-01\u0026#39;)), 19 PARTITION p20233 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-03-01\u0026#39;)) 20); 21 22-- 查询数据，检查是否只查询了数据所在的分区 23explain partitions select * from report_ads_sources where stat_day = \u0026#39;2023-01-06\u0026#39; 24 25-- 6 删除一个分区(分区的所有数据也都会被删除) 26alter table [tablename] drop PARTITION p20231; 27 28-- 7 新增一个分区 29alter table [tablename] add PARTITION (PARTITION p20234 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-04-01\u0026#39;))); 30 31-- 8 新增一个分区(不满足其余分区条件的都存放在这个分区) 32alter table [tablename] add PARTITION (PARTITION p20235 VALUES LESS THAN maxvalue); ","permalink":"https://www.silent-cxl.top/posts/mysql-partition/","summary":" 1-- 前面 4 步是操作分区的字段（设置为主键 PRIMARY），如果要分区的字段已是主键可跳过这几步 2 3-- 1. 移除 id 的自增 4alter table [tablename] modify id bigint(20)unsigned; 5 6-- 2. 移除主键 7alter table [tablename] drop PRIMARY KEY; 8 9-- 3. 重新添加主键 10alter table [tablename] add PRIMARY KEY(id,stat_day); 11 12-- 4. 重新设置 id 自增 13alter table [tablename] modify id bigint(20)unsigned AUTO_INCREMENT; 14 15-- 5. 正式分区语句 16ALTER TABLE [tablename] PARTITION BY RANGE (TO_DAYS(stat_day)) ( 17 PARTITION p20231 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-01-01\u0026#39;)), -- TO_DAYS(\u0026#39;20230101\u0026#39;) 18 PARTITION p20232 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-02-01\u0026#39;)), 19 PARTITION p20233 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-03-01\u0026#39;)) 20); 21 22-- 查询数据，检查是否只查询了数据所在的分区 23explain partitions select * from report_ads_sources where stat_day = \u0026#39;2023-01-06\u0026#39; 24 25-- 6 删除一个分区(分区的所有数据也都会被删除) 26alter table [tablename] drop PARTITION p20231; 27 28-- 7 新增一个分区 29alter table [tablename] add PARTITION (PARTITION p20234 VALUES LESS THAN (TO_DAYS(\u0026#39;2023-04-01\u0026#39;))); 30 31-- 8 新增一个分区(不满足其余分区条件的都存放在这个分区) 32alter table [tablename] add PARTITION (PARTITION p20235 VALUES LESS THAN maxvalue); ","title":"Mysql 设置数据库分区"},{"content":" 1// 7 天前的日期「3600 * 1000 * 24 * 7 几天前都可以以此方式得到」 2const start = new Date() 3start.setTime(start.getTime() - 3600 * 1000 * 24 * 7) 4 5// 本月第一天 6const start = new Date(new Date().setDate(1)) 7// 由上 -1 天 可以取到上月最后一天 8start.setTime(start.getTime() - 3600 * 1000 * 24 * 1) 9 10// 延伸得到上月日期 11const end = new Date(new Date().setDate(1)) 12end.setTime(end.getTime() - 3600 * 1000 * 24 * 1) 13const s = new Date(end - 0) // 日期深拷贝 14const start = new Date(s.setDate(1)) 15// 得到 start, end 上月的第一天和最后一天 ","permalink":"https://www.silent-cxl.top/posts/js-date/","summary":"1// 7 天前的日期「3600 * 1000 * 24 * 7 几天前都可以以此方式得到」 2const start = new Date() 3start.setTime(start.getTime() - 3600 * 1000 * 24 * 7) 4 5// 本月第一天 6const start = new Date(new Date().setDate(1)) 7// 由上 -1 天 可以取到上月最后一天 8start.setTime(start.getTime() - 3600 * 1000 * 24 * 1) 9 10// 延伸得到上月日期 11const end = new Date(new Date().setDate(1)) 12end.setTime(end.getTime() - 3600 * 1000 * 24 * 1) 13const s = new Date(end - 0) // 日期深拷贝 14const start = new Date(s.","title":"Js 日期处理"},{"content":" 修改数据库字符集 1ALTER DATABASE hiads DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 修改表字符集 1ALTER TABLE jobs CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 修改字段的字符集 1ALTER TABLE oauth_access_tokens CHANGE scopes scopes VARCHAR(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; ","permalink":"https://www.silent-cxl.top/posts/mysql-character/","summary":" 修改数据库字符集 1ALTER DATABASE hiads DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 修改表字符集 1ALTER TABLE jobs CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 修改字段的字符集 1ALTER TABLE oauth_access_tokens CHANGE scopes scopes VARCHAR(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; ","title":"Mysql 修改数据库、表字符集"},{"content":"原文地址：defer\n什么是 defer defer：在函数返回前，会执行 defer 关键字所传入的函数。 提出问题 多个 defer 的运行顺序是什么 传值时 defer 执行结果是否符合预期 defer 原理分析 \u0026hellip;..\n问题解释 后调用的 defer 函数会先执行： 后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面； 运行 runtime._defer 时是从前到后依次执行； 函数的参数会被预先计算； 调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算； ","permalink":"https://www.silent-cxl.top/go-design/defer/","summary":"原文地址：defer\n什么是 defer defer：在函数返回前，会执行 defer 关键字所传入的函数。 提出问题 多个 defer 的运行顺序是什么 传值时 defer 执行结果是否符合预期 defer 原理分析 \u0026hellip;..\n问题解释 后调用的 defer 函数会先执行： 后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面； 运行 runtime._defer 时是从前到后依次执行； 函数的参数会被预先计算； 调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算； ","title":"Go 语言设计与实现阅读笔记：Defer"},{"content":" git 在拉代码时报一下错误 1➜ scripts git:(master) git pull origin master 2来自 .......[远程仓库地址] 3 * branch master -\u0026gt; FETCH_HEAD 4致命错误：拒绝合并无关的历史 原因是仓库与本地版本不一致导致的，但确认代码是一致的，直接运行以下 git 命令 1git pull origin master --allow-unrelated-histories ","permalink":"https://www.silent-cxl.top/posts/git-pull-allow-unrelated-histories/","summary":" git 在拉代码时报一下错误 1➜ scripts git:(master) git pull origin master 2来自 .......[远程仓库地址] 3 * branch master -\u0026gt; FETCH_HEAD 4致命错误：拒绝合并无关的历史 原因是仓库与本地版本不一致导致的，但确认代码是一致的，直接运行以下 git 命令 1git pull origin master --allow-unrelated-histories ","title":"Git Pull 时报错：拒绝合并无关的历史"},{"content":" golang gorm 代码如下 1func (m *User) BatchInsert(users []*User) (err error) { 2 if len(users) == 0 { 3 return nil 4 } 5 // 要修改的字段 6 updateColumns := []string{\u0026#34;email\u0026#34;} 7 return m.Table(m.TableName()).Clauses(clause.OnConflict{ 8 DoUpdates: clause.AssignmentColumns(updateColumns), 9 }).CreateInBatches(users, 500).Error 10} debug 生成的代码，当数据重复时，会修改 email 字段，而不是插入 1INSERT INTO `users`(...) VALUES(...) ON DUPLICATE KEY UPDATE `email`=VALUES(`email`) ","permalink":"https://www.silent-cxl.top/posts/golang-gorm-on-duplicate-key-update/","summary":" golang gorm 代码如下 1func (m *User) BatchInsert(users []*User) (err error) { 2 if len(users) == 0 { 3 return nil 4 } 5 // 要修改的字段 6 updateColumns := []string{\u0026#34;email\u0026#34;} 7 return m.Table(m.TableName()).Clauses(clause.OnConflict{ 8 DoUpdates: clause.AssignmentColumns(updateColumns), 9 }).CreateInBatches(users, 500).Error 10} debug 生成的代码，当数据重复时，会修改 email 字段，而不是插入 1INSERT INTO `users`(...) VALUES(...) ON DUPLICATE KEY UPDATE `email`=VALUES(`email`) ","title":"Golang Gorm 插入数据遇到重复时修改"},{"content":" 给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。 - 如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。 - 给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。 示例 1： 1输入：coordinates = \u0026#34;a1\u0026#34; 2输出：false 3解释：如上图棋盘所示，\u0026#34;a1\u0026#34; 坐标的格子是黑色的，所以返回 false 。 go 题解\n1func squareIsWhite(coordinates string) bool { 2 // a-h 的字母转换 byte 为 ascii 数字，转换单双，一个单一个双才是白色 3 return (coordinates[0]%2)^(coordinates[1]%2) == 1 4} ","permalink":"https://www.silent-cxl.top/algorithm/leetcode-1812/","summary":" 给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。 - 如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。 - 给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。 示例 1： 1输入：coordinates = \u0026#34;a1\u0026#34; 2输出：false 3解释：如上图棋盘所示，\u0026#34;a1\u0026#34; 坐标的格子是黑色的，所以返回 false 。 go 题解\n1func squareIsWhite(coordinates string) bool { 2 // a-h 的字母转换 byte 为 ascii 数字，转换单双，一个单一个双才是白色 3 return (coordinates[0]%2)^(coordinates[1]%2) == 1 4} ","title":"Leetcode:1812、判断国际象棋棋盘中一个格子的颜色"},{"content":" 给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。 请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。 示例 1 1输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] 2输出：3 3解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 4- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。 5- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。 6- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。 示例 2 1输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6] 2输出：-1 3解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。 go 题解\n1func minOperations(nums1 []int, nums2 []int) int { 2 if len(nums1) \u0026gt; 6*len(nums2) || len(nums2) \u0026gt; 6*len(nums1) { 3 return -1 4 } 5 // 先算出两个数组相差多少 6 n := 0 7 for _, v := range nums1 { n += v } 8 for _, v := range nums2 { n -= v } 9 var smallNums, largeNums []int 10 if n \u0026gt; 0 { 11 smallNums, largeNums = nums2, nums1 12 } else { 13 n *= -1 14 smallNums, largeNums = nums1, nums2 15 } 16 // 排序方便以最大的差值变动数组元素 17 sort.Ints(smallNums) 18 sort.Ints(largeNums) 19 k := 0 20 s, l := 0, len(largeNums)-1 21 for n \u0026gt; 0 { 22 isSmall := true 23 diff := 0 24 // 小的数组以最大值 6 扣减算出差额 25 if s \u0026lt; len(smallNums) \u0026amp;\u0026amp; smallNums[s] \u0026lt; 6 { 26 diff = 6 - smallNums[s] 27 } 28 // 大的数组以最小值 1 扣减算出差额 29 if l \u0026gt;= 0 \u0026amp;\u0026amp; largeNums[l] \u0026gt; 1 { 30 if largeNums[l]-1 \u0026gt; diff { // diff 哪个差额大用哪个数组的元素变动 31 diff = largeNums[l] - 1 32 isSmall = false 33 } 34 } 35 // 扣减并叠加步数 36 n -= diff 37 k++ 38 if n \u0026lt;= 0 { 39 break 40 } 41 if isSmall { 42 s++ 43 } else { 44 l-- 45 } 46 } 47 48 return k 49} ","permalink":"https://www.silent-cxl.top/algorithm/leetcode-1775/","summary":"给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。 请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。 示例 1 1输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] 2输出：3 3解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 4- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。 5- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。 6- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。 示例 2 1输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6] 2输出：-1 3解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。 go 题解","title":"Leetcode:1775、通过最少操作次数使数组的和相等"},{"content":"在虚拟机中创建软连接时报错 Read-only file system，修改方法如下\n关闭虚拟机 用管理员身份启用cmd，进入到虚拟机安装目录(C:\\Program Files\\Oracle\\VirtualBox) 运行以下命令 1VBoxManage setextradata YOURVMNAME VBoxInternal2/SharedFoldersEnableSymlinksCreate/YOURSHAREFOLDERNAME 1 YOURVMNAME ：虚拟机中系统名称 YOURSHAREFOLDERNAME ：虚拟机本地共享文件夹名称(不用带路径) 查看是否配置成功\n1VBoxManage getextradata YOURVMNAME enumerate 参考博文：https://ahtik.com/fixing-your-virtualbox-shared-folder-symlink-error/\n","permalink":"https://www.silent-cxl.top/posts/virtual-read-only-file-system/","summary":"在虚拟机中创建软连接时报错 Read-only file system，修改方法如下\n关闭虚拟机 用管理员身份启用cmd，进入到虚拟机安装目录(C:\\Program Files\\Oracle\\VirtualBox) 运行以下命令 1VBoxManage setextradata YOURVMNAME VBoxInternal2/SharedFoldersEnableSymlinksCreate/YOURSHAREFOLDERNAME 1 YOURVMNAME ：虚拟机中系统名称 YOURSHAREFOLDERNAME ：虚拟机本地共享文件夹名称(不用带路径) 查看是否配置成功\n1VBoxManage getextradata YOURVMNAME enumerate 参考博文：https://ahtik.com/fixing-your-virtualbox-shared-folder-symlink-error/","title":"VirtualBox 虚拟机 Read-only file system"},{"content":"1ERROR: for local_nginx Cannot start service nginx: driver failed programming external connectivity on endpoint local_nginx (c3d788a28999dc7888524cd93d63a5dac3da0fe00d9c7d8a09e8bb815005b9f0): Bind for 0.0.0.0:8098 failed: port is already allocated 容器没有运行了，但是端口还在绑定占用\n解决：\nsystemctl stop docker.service rm /var/lib/docker/network/files/local-kv.db systemctl restart docker.service ","permalink":"https://www.silent-cxl.top/posts/docker-compose-port-is-already-allocated/","summary":"1ERROR: for local_nginx Cannot start service nginx: driver failed programming external connectivity on endpoint local_nginx (c3d788a28999dc7888524cd93d63a5dac3da0fe00d9c7d8a09e8bb815005b9f0): Bind for 0.0.0.0:8098 failed: port is already allocated 容器没有运行了，但是端口还在绑定占用\n解决：\nsystemctl stop docker.service rm /var/lib/docker/network/files/local-kv.db systemctl restart docker.service ","title":"Docker Compose Port Is Already Allocated"},{"content":" 记录一个遇到的文字色彩动画\n1.example { 2 display: block; 3 text-decoration: none; 4 background-image: -webkit-linear-gradient( 5 left, 6 #3498db, 7 #f47920 10%, 8 #d71345 20%, 9 #f7acbc 30%, 10 #ffd400 40%, 11 #3498db 50%, 12 #f47920 60%, 13 #d71345 70%, 14 #f7acbc 80%, 15 #ffd400 90%, 16 #3498db 17 ); 18 color: transparent; 19 -webkit-background-clip: text; 20 background-size: 200% 100%; 21 animation: slide 5s infinite linear; 22 font-size: 40px; 23} 24 25@keyframes slide { 26 0% { 27 background-position: 0 0; 28 } 29 100% { 30 background-position: -100% 0; 31 } 32} 原地址：图片裁剪\n","permalink":"https://www.silent-cxl.top/posts/css-font-color-animation/","summary":"记录一个遇到的文字色彩动画\n1.example { 2 display: block; 3 text-decoration: none; 4 background-image: -webkit-linear-gradient( 5 left, 6 #3498db, 7 #f47920 10%, 8 #d71345 20%, 9 #f7acbc 30%, 10 #ffd400 40%, 11 #3498db 50%, 12 #f47920 60%, 13 #d71345 70%, 14 #f7acbc 80%, 15 #ffd400 90%, 16 #3498db 17 ); 18 color: transparent; 19 -webkit-background-clip: text; 20 background-size: 200% 100%; 21 animation: slide 5s infinite linear; 22 font-size: 40px; 23} 24 25@keyframes slide { 26 0% { 27 background-position: 0 0; 28 } 29 100% { 30 background-position: -100% 0; 31 } 32} 原地址：图片裁剪","title":"Css 文字色彩动画"},{"content":"无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1 输入: s = \u0026ldquo;abcabcbb\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。 示例 2 输入: s = \u0026ldquo;bbbbb\u0026rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 \u0026ldquo;b\u0026rdquo;，所以其长度为 1。 示例 3 输入: s = \u0026ldquo;pwwkew\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;wke\u0026rdquo;，所以其长度为 3。 解题 1// 题解 1 2func lengthOfLongestSubstring1(str string) int { 3 maxLen := 0 4 hasStrings := make([]string, 0) 5 for i := 0; i \u0026lt; len(str); i++ { 6 current := str[i : i+1] 7 if key := stringInArray(hasStrings, current); key != -1 { 8 if stringsLen := len(hasStrings); maxLen \u0026lt; stringsLen { 9 maxLen = stringsLen 10 } 11 hasStrings = hasStrings[key+1:] 12 } 13 hasStrings = append(hasStrings, current) 14 } 15 if stringsLen := len(hasStrings); stringsLen \u0026gt; maxLen { 16 return stringsLen 17 } 18 return maxLen 19} 20func stringInArray(x []string, target string) int { 21 for key, v := range x { 22 if v == target { 23 return key 24 } 25 } 26 return -1 27} 28 29// 题解 2 30func lengthOfLongestSubstring(s string) int { 31 if s == \u0026#34;\u0026#34; { 32 return 0 33 } 34 tmp := make(map[byte]struct{}) 35 l, idx, maxLen := 0, 0, 0 36 bs := []byte(s) 37 for idx \u0026lt; len(s) { 38 if _, ok := tmp[bs[idx]]; ok { 39 if idx-l \u0026gt; maxLen { 40 maxLen = idx - l 41 } 42 l++ 43 idx = l 44 tmp = map[byte]struct{}{bs[idx]: {}} 45 } else { 46 tmp[bs[idx]] = struct{}{} 47 } 48 idx++ 49 } 50 if idx-l \u0026gt; maxLen { 51 maxLen = idx - l 52 } 53 return maxLen 54} ","permalink":"https://www.silent-cxl.top/algorithm/longest-substring/","summary":"无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1 输入: s = \u0026ldquo;abcabcbb\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。 示例 2 输入: s = \u0026ldquo;bbbbb\u0026rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 \u0026ldquo;b\u0026rdquo;，所以其长度为 1。 示例 3 输入: s = \u0026ldquo;pwwkew\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;wke\u0026rdquo;，所以其长度为 3。 解题 1// 题解 1 2func lengthOfLongestSubstring1(str string) int { 3 maxLen := 0 4 hasStrings := make([]string, 0) 5 for i := 0; i \u0026lt; len(str); i++ { 6 current := str[i : i+1] 7 if key := stringInArray(hasStrings, current); key !","title":"最长无重复子串"},{"content":" 在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n\u0026gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n每个节点都只有有限个子节点或无子节点； 没有父节点的节点称为根节点； 一个非根节点有且只有一个父节点； 了根节点外，每个子节点可以分为多个不相交的子树； 里面没有环路(cycle) go 语言递归树代码\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7type tree struct { 8 id int 9 pid int 10 node string 11 sub []tree 12} 13 14func main() { 15 t := []tree{ 16 {1, 0, \u0026#34;a\u0026#34;, nil}, 17 {2, 0, \u0026#34;b\u0026#34;, nil}, 18 {3, 1, \u0026#34;a1\u0026#34;, nil}, 19 {4, 1, \u0026#34;a2\u0026#34;, nil}, 20 {5, 1, \u0026#34;a3\u0026#34;, nil}, 21 {6, 3, \u0026#34;a11\u0026#34;, nil}, 22 {7, 3, \u0026#34;a12\u0026#34;, nil}, 23 {8, 4, \u0026#34;a21\u0026#34;, nil}, 24 {9, 2, \u0026#34;b1\u0026#34;, nil}, 25 {10, 2, \u0026#34;b2\u0026#34;, nil}, 26 {11, 10, \u0026#34;b21\u0026#34;, nil}, 27 } 28 fmt.Println(formatTree(t, 0)) 29} 30 31func formatTree(t []tree, pid int) (res []tree) { 32 for _, v := range t { 33 if pid == v.pid { 34 v.sub = formatTree(t, v.id) 35 res = append(res, v) 36 } 37 } 38 return 39} ","permalink":"https://www.silent-cxl.top/algorithm/tree/","summary":"在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n\u0026gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n每个节点都只有有限个子节点或无子节点； 没有父节点的节点称为根节点； 一个非根节点有且只有一个父节点； 了根节点外，每个子节点可以分为多个不相交的子树； 里面没有环路(cycle) go 语言递归树代码\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7type tree struct { 8 id int 9 pid int 10 node string 11 sub []tree 12} 13 14func main() { 15 t := []tree{ 16 {1, 0, \u0026#34;a\u0026#34;, nil}, 17 {2, 0, \u0026#34;b\u0026#34;, nil}, 18 {3, 1, \u0026#34;a1\u0026#34;, nil}, 19 {4, 1, \u0026#34;a2\u0026#34;, nil}, 20 {5, 1, \u0026#34;a3\u0026#34;, nil}, 21 {6, 3, \u0026#34;a11\u0026#34;, nil}, 22 {7, 3, \u0026#34;a12\u0026#34;, nil}, 23 {8, 4, \u0026#34;a21\u0026#34;, nil}, 24 {9, 2, \u0026#34;b1\u0026#34;, nil}, 25 {10, 2, \u0026#34;b2\u0026#34;, nil}, 26 {11, 10, \u0026#34;b21\u0026#34;, nil}, 27 } 28 fmt.","title":"递归树"},{"content":" 斐波那契数（意大利语：Successione di Fibonacci），又译为菲波拿契数、菲波那西数、斐氏数、黄金分割数。所形成的数列称为斐波那契数列（意大利语：Successione di Fibonacci），又译为菲波拿契数列、菲波那西数列、斐氏数列、黄金分割数列。\n在数学上，斐波那契数是以递归的方法来定义：\nF0 = 0 F1 = 1 Fn = Fn-1 + Fn-2 用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出。\n1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987\u0026hellip;\u0026hellip; 特别指出：0不是第一项，而是第零项。\n1func fibonacci(n int) int { 2 if n \u0026lt; 3 { 3 return 1 4 } 5 return fibonacci(n-1) + fibonacci(n-2) 6} 7# fibonacci(5) ","permalink":"https://www.silent-cxl.top/algorithm/fibonacci/","summary":" 斐波那契数（意大利语：Successione di Fibonacci），又译为菲波拿契数、菲波那西数、斐氏数、黄金分割数。所形成的数列称为斐波那契数列（意大利语：Successione di Fibonacci），又译为菲波拿契数列、菲波那西数列、斐氏数列、黄金分割数列。\n在数学上，斐波那契数是以递归的方法来定义：\nF0 = 0 F1 = 1 Fn = Fn-1 + Fn-2 用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出。\n1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987\u0026hellip;\u0026hellip; 特别指出：0不是第一项，而是第零项。\n1func fibonacci(n int) int { 2 if n \u0026lt; 3 { 3 return 1 4 } 5 return fibonacci(n-1) + fibonacci(n-2) 6} 7# fibonacci(5) ","title":"Fibonacci 斐波那契数列"},{"content":"先上 github-acitons 部署 yml 文件内容 1name: 部署到服务器 2on: 3 push: 4 branches: [ \u0026#34;master\u0026#34; ] # master 分支有提交自动部署 5 6permissions: write-all 7jobs: 8 deploy: 9 name: Deploy 10 runs-on: ubuntu-latest 11 environment: production 12 13 steps: 14 # 获取源码 master 分支，也可以写 tag 版本 15 - name: Checkout 16 uses: actions/checkout@master 17 18 # 使用到的这个 easingthemes/ssh-deploy actions，main 表示主分支 19 # 可以直接仓库搜索到：easingthemes/ssh-deploy，有介绍下面的配置项 20 - name: 部署到服务器 21 uses: easingthemes/ssh-deploy@main 22 env: 23 SSH_PRIVATE_KEY: ${{ secrets.BLOG_ECS_KEY }} 24 ARGS: \u0026#34;-avzr --delete\u0026#34; # 部署前删除目录 25 SOURCE: \u0026#34;public/\u0026#34; 26 REMOTE_HOST: ${{ secrets.BLOG_ECS_HOST }} 27 REMOTE_USER: ${{ secrets.BLOG_ECS_USER }} 28 TARGET: ${{ secrets.BLOG_ECS_TARGET }} 首先开启 github 仓库的 actions 功能 两种方式\n第一种 进入 github 找到你要部署的仓库 进入 actions 后点击 -\u0026gt; Skip this and **set up a workflow yourself** 编写 yml 文件 第二种 直接在项目根目录创建 .github/workflows/deploy.yml 随项目一起提交（文件名可自定义）\neasingthemes/ssh-deploy 配置 SSH_PRIVATE_KEY\n按以下步骤执行\n进入你的服务器，在 /root/.ssh/ 目录查看是否有 id_rsa.pub 公钥和 id_rsa 私钥 没有：运行 ssh-keygen -m PEM -t rsa -b 4096 生成，有就跳过此步 cp id_rsa.pub authorized_keys cat id_rsa 查看并复制私钥，要复制全部内容 此时回到仓库，将第4步复制的私钥填入仓库的 settings.Secrets.Actions 按照定义的 key.value 添加 SOURCE\n要部署的项目目录，如 dist,public\nREMOTE_HOST\n服务器 IP\nREMOTE_USER\n服务器用户名\nTARGET\n要部署到服务器哪个目录\n","permalink":"https://www.silent-cxl.top/posts/deploy-github-actions/","summary":"先上 github-acitons 部署 yml 文件内容 1name: 部署到服务器 2on: 3 push: 4 branches: [ \u0026#34;master\u0026#34; ] # master 分支有提交自动部署 5 6permissions: write-all 7jobs: 8 deploy: 9 name: Deploy 10 runs-on: ubuntu-latest 11 environment: production 12 13 steps: 14 # 获取源码 master 分支，也可以写 tag 版本 15 - name: Checkout 16 uses: actions/checkout@master 17 18 # 使用到的这个 easingthemes/ssh-deploy actions，main 表示主分支 19 # 可以直接仓库搜索到：easingthemes/ssh-deploy，有介绍下面的配置项 20 - name: 部署到服务器 21 uses: easingthemes/ssh-deploy@main 22 env: 23 SSH_PRIVATE_KEY: ${{ secrets.","title":"记录 Github Actions 实现代码提交自动部署"},{"content":" 1// func shuffle[T any](slice []T) { // go1.18 及以上 2func shuffle(slice []int64) { 3 if len(slice) == 1 { 4 return 5 } 6 r := rand.New(rand.NewSource(time.Now().UnixNano())) 7 for len(slice) \u0026gt; 0 { 8 n := len(slice) 9 randIndex := r.Intn(n) 10 slice[n-1], slice[randIndex] = slice[randIndex], slice[n-1] 11 slice = slice[:n-1] 12 } 13} ","permalink":"https://www.silent-cxl.top/posts/golang-shuffle/","summary":" 1// func shuffle[T any](slice []T) { // go1.18 及以上 2func shuffle(slice []int64) { 3 if len(slice) == 1 { 4 return 5 } 6 r := rand.New(rand.NewSource(time.Now().UnixNano())) 7 for len(slice) \u0026gt; 0 { 8 n := len(slice) 9 randIndex := r.Intn(n) 10 slice[n-1], slice[randIndex] = slice[randIndex], slice[n-1] 11 slice = slice[:n-1] 12 } 13} ","title":"Go 打乱数据排序"},{"content":"Hugo 的安装 安装可查看 官方文档 安装完成后按照文档的快速启动项目操作 1# 创建一个项目 2hugo new site [项目名称，如：myblog] 3 4# 进入你的项目，后面所有的命令都是在项目根目录执行（未特殊标明的） 5cd myblog 6 7# 初始化 git 仓库 8git init 9git remote add origin [你的 github/gitee/gitlab 仓库地址] 下载一个你喜欢的主题 官方文档 主题库 这里有很多 我使用的是这个 主题 stars 还挺多的 直接在你的项目目录执行下面 git 命令就可以了 1git clone [主题仓库地址] themes/主题名 配置你的主题 项目根目录 config.toml 文件 1# 设置主题 2theme = \u0026#34;PaperMod\u0026#34; 具体主题相关配置可按照自己下载的主体来，如我使用的这个主体可以在他的仓库看下有 exampleSite 分支，切到这个分支下可找到 config.yml 文件 PS：如果主题的配置文件是 yml 或 yaml 格式，可以随便百度或 google yml to toml 解决配置转换问题\n创建你的内容 运行如下命令 1hugo new posts/first-post.md 在 content/posts/ 里可以看到刚刚创建的 md 文件，一般内容头部（更多可以在官网查看） 1title: \u0026#34;使用 Hugo 搭建自己的博客\u0026#34; 2date: 2022-11-24T20:48:28+08:00 3draft: false # 是否是草稿，构建的时候可以用上 4description: \u0026#34;使用 Hugo 搭建自己的博客\u0026#34; 5categories: [\u0026#34;hugo\u0026#34;] # 数组，分类可以用上 6tags: [\u0026#34;hugo\u0026#34;, \u0026#34;博客搭建\u0026#34;] # 数组，标签可以用上 7ShowToc: true # 是否显示内容页的目录 8cover: 9 image: \u0026#34;\u0026#34; # 列表展示的图片 启动 1hugo server -D # -D buildDraft 构建草稿 2 3 4Start building sites … 5hugo v0.106.0+extended darwin/amd64 BuildDate=unknown 6.... 7.... 8Environment: \u0026#34;development\u0026#34; 9Serving pages from memory 10Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender 11Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 12Press Ctrl+C to stop 这时就可以在浏览器打开你构建出来的地址了：http://localhost:1313/ 发布 直接运行 hugo 命令，完成后可以在根目录找到 public 目录，是纯 html 格式的文件，将整个目录丢到 nginx 或其他服务器运行就可以了 1hugo 附上 nginx 的 https 配置，如果不需要 https 直接去掉注释标注 https 中间部分然后监听 80 端口即可\n1server { 2 #SSL 默认访问端口号为 443 3 #listen 80; 4 listen 443 ssl; 5 #请填写绑定证书的域名 6 server_name www.silent-cxl.top silent-cxl.top; 7 8 ############# https ############# 9 #请填写证书文件的相对路径或绝对路 10 ssl_certificate cert/silent-cxl.top.crt; 11 #请填写私钥文件的相对路径或绝对路径 12 ssl_certificate_key cert/silent-cxl.top.key; 13 ssl_session_timeout 5m; 14 #请按照以下协议配置 15 ssl_protocols TLSv1.2 TLSv1.3; 16 #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 17 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; 18 ssl_prefer_server_ciphers on; 19 ############# https ############# 20 21 root /usr/share/nginx/html/site/public/; 22 index index.html index.htm; 23 24 access_log /var/log/nginx/access.hugosite.log main; 25 error_log /var/log/nginx/error.hugosite.log; 26 27 location / { 28 try_files $uri $uri/ /index.html; 29 } 30 31 error_page 500 502 503 504 /50x.html; 32 location = /50x.html { 33 root /usr/share/nginx/html; 34 } 35} 36 37############# https ############# 38server { 39 listen 80; 40 #请填写绑定证书的域名 41 server_name www.silent-cxl.top; 42 #把http的域名请求转成https 43 return 301 https://$host$request_uri; 44} 45############# https ############# ","permalink":"https://www.silent-cxl.top/posts/hugo-build-blog/","summary":"Hugo 的安装 安装可查看 官方文档 安装完成后按照文档的快速启动项目操作 1# 创建一个项目 2hugo new site [项目名称，如：myblog] 3 4# 进入你的项目，后面所有的命令都是在项目根目录执行（未特殊标明的） 5cd myblog 6 7# 初始化 git 仓库 8git init 9git remote add origin [你的 github/gitee/gitlab 仓库地址] 下载一个你喜欢的主题 官方文档 主题库 这里有很多 我使用的是这个 主题 stars 还挺多的 直接在你的项目目录执行下面 git 命令就可以了 1git clone [主题仓库地址] themes/主题名 配置你的主题 项目根目录 config.toml 文件 1# 设置主题 2theme = \u0026#34;PaperMod\u0026#34; 具体主题相关配置可按照自己下载的主体来，如我使用的这个主体可以在他的仓库看下有 exampleSite 分支，切到这个分支下可找到 config.yml 文件 PS：如果主题的配置文件是 yml 或 yaml 格式，可以随便百度或 google yml to toml 解决配置转换问题\n创建你的内容 运行如下命令 1hugo new posts/first-post.","title":"使用 Hugo 搭建自己的博客"},{"content":"创建评论使用的 github 仓库 操作步骤如下图（utteranc 的操作截图） giscus 驱动与 utteranc 驱动开启操作大同小异，步骤基本相同 创建好后如我的：https://github.com/cxlcxl/comments-for-hugo，而后可在最底下的 Enable Utterances 部分取到配置 Hugo 配置文件文件修改 config.toml\n1[params] 2# ... 3comments = true 4 #使用的是 utteranc 评论，教程参考 https://utteranc.es/ 5 [params.utteranc] 6 enable = false 7 repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 8 issueTerm = \u0026#34;pathname\u0026#34; 9 theme = \u0026#34;github-light\u0026#34; 10 11 ## 配置 giscus 评论,教程参考 https://giscus.app/zh-CN 12 [params.giscus] 13 enable = true 14 repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 15 repoId = \u0026#34;\u0026#34; 16 category = \u0026#34;\u0026#34; 17 categoryId = \u0026#34;\u0026#34; 18 mapping = \u0026#34;pathname\u0026#34; 19 theme = \u0026#34;light_protanopia\u0026#34; 20 lang = \u0026#34;zh-CN\u0026#34; 21 crossorigin = \u0026#34;anonymous\u0026#34; comments.html 文件修改 文件位置：themes/PaperMod/layouts/partials/comments.html\n1{{- /* Comments area start */ -}} 2{{- /* to add comments read =\u0026gt; https://gohugo.io/content-management/comments/ */ -}} 3 4{{ if .Site.Params.utteranc.enable }} 5 6\u0026lt;div class=\u0026#34;post bg-white\u0026#34;\u0026gt; 7 \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; 8 repo= \u0026#34;{{ .Site.Params.utteranc.repo }}\u0026#34; 9 issue-term=\u0026#34;{{ .Site.Params.utteranc.issueTerm }}\u0026#34; 10 theme=\u0026#34;{{ .Site.Params.utteranc.theme }}\u0026#34; 11 crossorigin=\u0026#34;anonymous\u0026#34; 12 async\u0026gt; 13 \u0026lt;/script\u0026gt; 14\u0026lt;/div\u0026gt; 15 16{{ else if .Site.Params.giscus.enable }} 17 18\u0026lt;div class=\u0026#34;post bg-white\u0026#34;\u0026gt; 19 \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; 20 data-repo=\u0026#34;{{ .Site.Params.giscus.repo }}\u0026#34; 21 data-repo-id=\u0026#34;{{ .Site.Params.giscus.repoId }}\u0026#34; 22 data-category=\u0026#34;{{ .Site.Params.giscus.category }}\u0026#34; 23 data-category-id=\u0026#34;{{ .Site.Params.giscus.categoryId }}\u0026#34; 24 data-mapping=\u0026#34;{{ .Site.Params.giscus.mapping }}\u0026#34; 25 data-strict=\u0026#34;0\u0026#34; 26 data-reactions-enabled=\u0026#34;1\u0026#34; 27 data-emit-metadata=\u0026#34;0\u0026#34; 28 data-input-position=\u0026#34;bottom\u0026#34; 29 data-theme=\u0026#34;{{ .Site.Params.giscus.theme }}\u0026#34; 30 data-lang=\u0026#34;{{ .Site.Params.giscus.lang }}\u0026#34; 31 crossorigin=\u0026#34;{{ .Site.Params.giscus.crossorigin }}\u0026#34; 32 async\u0026gt; 33\u0026lt;/script\u0026gt; 34\u0026lt;/div\u0026gt; 35 36{{ end }} 37 38{{- /* Comments area end */ -}} ","permalink":"https://www.silent-cxl.top/posts/hugo-supprt-comments/","summary":"创建评论使用的 github 仓库 操作步骤如下图（utteranc 的操作截图） giscus 驱动与 utteranc 驱动开启操作大同小异，步骤基本相同 创建好后如我的：https://github.com/cxlcxl/comments-for-hugo，而后可在最底下的 Enable Utterances 部分取到配置 Hugo 配置文件文件修改 config.toml\n1[params] 2# ... 3comments = true 4 #使用的是 utteranc 评论，教程参考 https://utteranc.es/ 5 [params.utteranc] 6 enable = false 7 repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 8 issueTerm = \u0026#34;pathname\u0026#34; 9 theme = \u0026#34;github-light\u0026#34; 10 11 ## 配置 giscus 评论,教程参考 https://giscus.app/zh-CN 12 [params.giscus] 13 enable = true 14 repo = \u0026#34;cxlcxl/comments-for-hugo\u0026#34; # 改成自己的配置 15 repoId = \u0026#34;\u0026#34; 16 category = \u0026#34;\u0026#34; 17 categoryId = \u0026#34;\u0026#34; 18 mapping = \u0026#34;pathname\u0026#34; 19 theme = \u0026#34;light_protanopia\u0026#34; 20 lang = \u0026#34;zh-CN\u0026#34; 21 crossorigin = \u0026#34;anonymous\u0026#34; comments.","title":"Hugo PaperMod 开启评论"},{"content":"创建命名空间 如果在default命名空间上可以跳过此步骤 1kubectl create ns bs 2 3// 可以查看刚刚创建的 namespace 4kubectl get ns 创建 k8s 账号权限 创建 ads-test-auth.yaml 配置文件如下 1#创建账号 2apiVersion: v1 3kind: ServiceAccount 4metadata: 5 namespace: bs 6 name: ads-test 7 8--- 9#创建角色对应操作 10apiVersion: rbac.authorization.k8s.io/v1 11kind: ClusterRole 12metadata: 13 name: discovery-ads-test 14rules: 15- apiGroups: [\u0026#34;\u0026#34;] 16 resources: [\u0026#34;endpoints\u0026#34;] # endpoints 17 verbs: [\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;] 18 19--- 20#给账号绑定角色 21apiVersion: rbac.authorization.k8s.io/v1 22kind: ClusterRoleBinding 23metadata: 24 name: find-ads-test-discovery-ads-test 25roleRef: 26 apiGroup: rbac.authorization.k8s.io 27 kind: ClusterRole 28 name: discovery-ads-test 29subjects: 30- kind: ServiceAccount 31 name: ads-test 32 namespace: bs 运行 kubectl apply -f ads-test-auth.yaml 创建资源\n进入你的 go-zero 项目 API 模块 如果原配置文件的 rpc 使用的是：Endpoints，可以改成：Target 方式，示例： 1# .... 2UserRpcClient: 3 # 原 4 #Endpoints: 5 # - \u0026#34;127.0.0.1:8002\u0026#34; 6 7 # 改为 结构 =\u0026gt; k8s://namespace/service:RPC 端口 8 Target: \u0026#34;k8s://bs/user-rpc-svc:8002\u0026#34; 9# .... 生成 dockerfile 1goctl docker -go user.go 切换到项目根路径制作镜像 1docker build -f xxxxxxx/Dockerfile -t xx:xx . 可以推送到远程或本地镜像仓库方便多节点部署，本机也可以直接 docker save 之后上传 进入服务目录生成 api K8S yaml 文件 1goctl kube --nodePort 30010 deploy -replicas 3 -requestCpu 100 -requestMem 50 -limitCpu 200 -limitMem 100 -name user-api -namespace bs -image user-api:v1.0 -o user-api.yaml -port 8001 --serviceAccount find-endpoints —nodePort K8S 限制端口在 30000-? 之间，不填则系统随机 RPC 模块 rpc docker 文件创建与 api 一致 进入 rpc 服务目录生成 K8S yaml 文件 1goctl kube deploy -replicas 3 -requestCpu 100 -requestMem 50 -limitCpu 200 -limitMem 100 -name user-rpc -namespace bs -image user-rpc:v1.0 -o user-rpc.yaml -port 8002 --serviceAccount find-endpoints 运行生成的 k8s 文件 如果多节点且 docker 镜像没有上传镜像仓库，需要提前上传 1kubectl apply -f user-rpc.yaml 2kubectl apply -f user-api.yaml 3 4# 检查问题与查看资源清单命令 5kubectl get pod,svc,deploy -n bs # 一起查看，单个查看分开执行 6kubectl describe pod [pod名] -n bs # 可以查看执行详细情况 7kubectl logs [pod名] -n bs # 查看日志 等待运行完成本机就可以通过 api 的 yaml 文件定义的端口 30010 进行访问了\n","permalink":"https://www.silent-cxl.top/posts/k8s-go-zero-deploy/","summary":"创建命名空间 如果在default命名空间上可以跳过此步骤 1kubectl create ns bs 2 3// 可以查看刚刚创建的 namespace 4kubectl get ns 创建 k8s 账号权限 创建 ads-test-auth.yaml 配置文件如下 1#创建账号 2apiVersion: v1 3kind: ServiceAccount 4metadata: 5 namespace: bs 6 name: ads-test 7 8--- 9#创建角色对应操作 10apiVersion: rbac.authorization.k8s.io/v1 11kind: ClusterRole 12metadata: 13 name: discovery-ads-test 14rules: 15- apiGroups: [\u0026#34;\u0026#34;] 16 resources: [\u0026#34;endpoints\u0026#34;] # endpoints 17 verbs: [\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;] 18 19--- 20#给账号绑定角色 21apiVersion: rbac.authorization.k8s.io/v1 22kind: ClusterRoleBinding 23metadata: 24 name: find-ads-test-discovery-ads-test 25roleRef: 26 apiGroup: rbac.authorization.k8s.io 27 kind: ClusterRole 28 name: discovery-ads-test 29subjects: 30- kind: ServiceAccount 31 name: ads-test 32 namespace: bs 运行 kubectl apply -f ads-test-auth.","title":"K8s 上 Go-Zero 服务本机手动部署记录"},{"content":" 匹配中间文件夹 示例 .gitignore 内容：匹配 app 下的所有模块文件夹下 config 下以 .pro.yaml 结尾的文件\n1// app/user/config/databse.pro.yaml 2// app/goods/config/databse.pro.yaml 3// ... 4app/**/config/*.pro.yaml 忽略已被提交到远程仓库的文件 先移除本地 git 缓存 1git rm --cached [要忽略的文件路径] 补充 .gitignore 文件内容即可 ","permalink":"https://www.silent-cxl.top/posts/git-ignore-use/","summary":" 匹配中间文件夹 示例 .gitignore 内容：匹配 app 下的所有模块文件夹下 config 下以 .pro.yaml 结尾的文件\n1// app/user/config/databse.pro.yaml 2// app/goods/config/databse.pro.yaml 3// ... 4app/**/config/*.pro.yaml 忽略已被提交到远程仓库的文件 先移除本地 git 缓存 1git rm --cached [要忽略的文件路径] 补充 .gitignore 文件内容即可 ","title":"Git 忽略文件使用"},{"content":" 世界上有 10 种人，懂二进制和不懂二进制的，实际上二进制只有 0 和 1，逢 2 进 1，所以 10 在二进制中并不是十进制的 10 而是十进制的 2。\n进制就是逢几进一，n 进制就是逢 n 进一。计算机只能识别二进制，人类最习惯使用的是十进制，而为了实际需要，又建立了八进制和十六进制。八进制就是逢八进一，十六进制就是逢十六进一。\n二进制转十进制 例二进制数：10010110，可转换如下\n1 1 0 0 1 0 1 1 0 // 二进制 21*2^7 + 0*2^6 + 0*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 0*2^0 3128 + 0 + 0 + 16 + 0 + 4 + 2 + 0 = 150 // 十进制 八进制转十进制 八进制：只有 0~7，逢 8 进 1\n例八进制数：256320，可转换如下\n1 2 5 6 3 2 0 // 八进制 22*8^5 + 5*8^4 + 6*8^3 + 3*8^2 + 2*8^1 + 0*8^0 365536 + 20480 + 3072 + 192 + 16 + 0 = 89296 // 十进制 十六进制转十进制 十六进制稍微特殊，但是转换与上面两种相同：只有 0~9,a,b,c,d,e,f，逢 16 进 1\n例十六进制数：30af，可转换如下\n1 3 0 a f // 十六进制 23*16^3 + 0*16^2 + 10*16^1 + 15*16^0 312288 + 0 + 160 + 15 = 12463 // 十进制 转十进制总结：都是 位上的数字 * 进制 ^ 权重\n十进制转二进制 例十进制数：562，可如下做除非换算\n1// 562 为被除数，除数为 2，直到商除为 0 停止，将余数从下往上连接既是转换结果： 2 32 | 562 4 ----- 5 2 | 281 ----------- 0 6 ----- 7 2 | 140 ---------- 1 8 ----- 9 2 | 70 --------- 0 10 ----- 11 2 | 35 -------- 0 12 ----- 13 2 | 17 ------- 1 14 ----- 15 2 | 8 ------ 1 16 ----- 17 2 | 4 ----- 0 18 ----- 19 2 | 2 ---- 0 20 ----- 21 2 | 1 --- 0 22 ----- 23 0 -- 1 24 25// 结果：1000110010 十进制转八进制，十进制转十六进制同转二进制一个方式，而非十进制间的转换就可以通过十进制中转即可。\n","permalink":"https://www.silent-cxl.top/posts/computer-conversion/","summary":"世界上有 10 种人，懂二进制和不懂二进制的，实际上二进制只有 0 和 1，逢 2 进 1，所以 10 在二进制中并不是十进制的 10 而是十进制的 2。\n进制就是逢几进一，n 进制就是逢 n 进一。计算机只能识别二进制，人类最习惯使用的是十进制，而为了实际需要，又建立了八进制和十六进制。八进制就是逢八进一，十六进制就是逢十六进一。\n二进制转十进制 例二进制数：10010110，可转换如下\n1 1 0 0 1 0 1 1 0 // 二进制 21*2^7 + 0*2^6 + 0*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 0*2^0 3128 + 0 + 0 + 16 + 0 + 4 + 2 + 0 = 150 // 十进制 八进制转十进制 八进制：只有 0~7，逢 8 进 1","title":"进制转换"},{"content":" 1import { defineConfig, loadEnv } from \u0026#34;vite\u0026#34; 2import vue from \u0026#34;@vitejs/plugin-vue\u0026#34; 3import path from \u0026#34;path\u0026#34; 4import { nodePolyfills } from \u0026#34;vite-plugin-node-polyfills\u0026#34; 5 6// https://vitejs.dev/config/ 7export default defineConfig(({ command, mode }) =\u0026gt; { 8 console.log(\u0026#34;vite.config defineConfig\u0026#34;, command, mode) 9 const env = loadEnv(mode, process.cwd(), \u0026#34;\u0026#34;) 10 return { 11 plugins: [ 12 vue(), 13 nodePolyfills({ 14 protocolImports: true, 15 }), 16 ], 17 resolve: { 18 alias: { 19 \u0026#34;@\u0026#34;: path.resolve(__dirname, \u0026#34;src\u0026#34;), 20 \u0026#34;@v\u0026#34;: path.resolve(__dirname, \u0026#34;src/views\u0026#34;), 21 \u0026#34;@a\u0026#34;: path.resolve(__dirname, \u0026#34;src/apis\u0026#34;), 22 }, 23 }, 24 define: { 25 \u0026#34;process.env\u0026#34;: env, 26 }, 27 server: { 28 proxy: { 29 \u0026#34;/api/\u0026#34;: { 30 target: process.env.VUE_APP_BASE_API, 31 changeOrigin: true, 32 rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#34;\u0026#34;), 33 }, 34 }, 35 }, 36 } 37}) ","permalink":"https://www.silent-cxl.top/posts/vue-vite/","summary":"1import { defineConfig, loadEnv } from \u0026#34;vite\u0026#34; 2import vue from \u0026#34;@vitejs/plugin-vue\u0026#34; 3import path from \u0026#34;path\u0026#34; 4import { nodePolyfills } from \u0026#34;vite-plugin-node-polyfills\u0026#34; 5 6// https://vitejs.dev/config/ 7export default defineConfig(({ command, mode }) =\u0026gt; { 8 console.log(\u0026#34;vite.config defineConfig\u0026#34;, command, mode) 9 const env = loadEnv(mode, process.cwd(), \u0026#34;\u0026#34;) 10 return { 11 plugins: [ 12 vue(), 13 nodePolyfills({ 14 protocolImports: true, 15 }), 16 ], 17 resolve: { 18 alias: { 19 \u0026#34;@\u0026#34;: path.","title":"Vue3 Vite 使用基础配置"},{"content":" Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n目录结构：\n1|--public 2|--src 3... 4|----store # 新建 vuex 相关文件夹 5|------modules # 新建模块文件夹，存放 app.js,user.js 6|--------global.js 7|--------getters.js 8|--------app.js 9|--------user.js store 文件夹下创建 index.js 1import { createStore } from \u0026#34;vuex\u0026#34; 2 3import global from \u0026#34;./modules/global.js\u0026#34; 4import app from \u0026#34;./modules/app.js\u0026#34; // 应用基本数据 5import user from \u0026#34;./modules/user.js\u0026#34; // 登录信息 6import getters from \u0026#34;./modules/getters.js\u0026#34; 7 8export default createStore({ 9 // 公共模板直接在这里展开就可以 10 ...global, 11 modules: { 12 app, 13 user, 14 }, 15 getters, 16}) main.js 中导入 1import store from \u0026#34;./store/index.js\u0026#34; 2 3createApp(App).use(store) 4 5// ... modules 文件夹下创建 app.js,user.js 1// user.js 内容，app.js 与 user.js 结构一致 2import md5 from \u0026#34;js-md5\u0026#34; 3import { login, getUserInfo, logout } from \u0026#34;@a/user\u0026#34; 4import { setToken, getToken, delToken } from \u0026#34;@/utils/token\u0026#34; 5 6// 用户 7export default { 8 namespaced: true, 9 state: { 10 email: \u0026#34;\u0026#34;, 11 username: \u0026#34;\u0026#34;, 12 token: \u0026#34;\u0026#34;, 13 user_id: \u0026#34;\u0026#34;, 14 }, 15 mutations: { 16 setLoginInfo(state, { email, user_id, username }) { 17 state.email = email 18 state.user_id = user_id 19 state.username = username 20 }, 21 setToken(state, { token }) { 22 state.token = token 23 setToken(token) 24 }, 25 }, 26 actions: { 27 login(store, { email, pass }) { 28 return new Promise((resolve, reject) =\u0026gt; { 29 login({ email, pass: md5(pass) }) 30 .then((res) =\u0026gt; { 31 const { email, token, user_id, username } = res.data 32 store.commit(\u0026#34;setLoginInfo\u0026#34;, { email, user_id, username }) 33 store.commit(\u0026#34;setToken\u0026#34;, { token }) 34 resolve(res.data) 35 }) 36 .catch(() =\u0026gt; { 37 reject() 38 }) 39 }) 40 }, 41 getUserInfo(store) { 42 return new Promise((resolve, reject) =\u0026gt; { 43 getUserInfo(getToken()) 44 .then((res) =\u0026gt; { 45 const { email, user_id, username } = res.data 46 store.commit(\u0026#34;setLoginInfo\u0026#34;, { email, user_id, username }) 47 resolve(res.data) 48 }) 49 .catch(() =\u0026gt; { 50 delToken() 51 reject() 52 }) 53 }) 54 }, 55 logout(store) { 56 return new Promise((resolve, reject) =\u0026gt; { 57 logout() 58 .then(() =\u0026gt; { 59 delToken() 60 resolve() 61 }) 62 .catch(() =\u0026gt; { 63 reject() 64 }) 65 }) 66 }, 67 }, 68} 69 70 71// getters.js 内容 72export default { 73 user_id: (state, getters) =\u0026gt; state.user.user_id, 74 email: (state, getters) =\u0026gt; state.user.email, 75 username: (state, getters) =\u0026gt; state.user.username, 76 token: (state, getters) =\u0026gt; state.user.token, 77} 78 79// global.js 内容 80export default { 81 state: {}, 82 mutations: {}, 83 actions: {}, 84 getters: {}, 85} vue3 页面组件中使用方式 1import { useStore } from \u0026#34;vuex\u0026#34; 2 3const store = useStore() // store 就是 vuex 对象 4 5// 例 6store.dispatch(\u0026#34;user/login\u0026#34;, form).then((res) =\u0026gt; { 7 // 成功的逻辑 8 // ... 9}).catch(() =\u0026gt; {}) ","permalink":"https://www.silent-cxl.top/posts/vue-vuex/","summary":"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n目录结构：\n1|--public 2|--src 3... 4|----store # 新建 vuex 相关文件夹 5|------modules # 新建模块文件夹，存放 app.js,user.js 6|--------global.js 7|--------getters.js 8|--------app.js 9|--------user.js store 文件夹下创建 index.js 1import { createStore } from \u0026#34;vuex\u0026#34; 2 3import global from \u0026#34;./modules/global.js\u0026#34; 4import app from \u0026#34;./modules/app.js\u0026#34; // 应用基本数据 5import user from \u0026#34;./modules/user.js\u0026#34; // 登录信息 6import getters from \u0026#34;./modules/getters.js\u0026#34; 7 8export default createStore({ 9 // 公共模板直接在这里展开就可以 10 ...global, 11 modules: { 12 app, 13 user, 14 }, 15 getters, 16}) main.","title":"Vue3 使用 Vuex 做登录信息"},{"content":" 直接上代码\n1// intercept.js 2import NProgress from \u0026#34;nprogress\u0026#34; 3import \u0026#34;nprogress/nprogress.css\u0026#34; // progress bar style 4import store from \u0026#34;@/store\u0026#34; 5import router from \u0026#34;./router\u0026#34; 6import settings from \u0026#34;./settings\u0026#34; 7import { getToken } from \u0026#34;@/utils/token\u0026#34; 8import { ElMessage } from \u0026#34;element-plus\u0026#34; 9 10NProgress.configure({ showSpinner: false }) 11const excludeUris = [\u0026#34;/login\u0026#34;, \u0026#34;/sso/callback\u0026#34;] 12 13router.beforeEach(async (to, from, next) =\u0026gt; { 14 NProgress.start() 15 // 顺便设置 icon title 16 document.title = to.meta.title 17 ? `${to.meta.title} - ${settings.title}` 18 : settings.title 19 20 const token = getToken() 21 if (token) { 22 if (to.path === \u0026#34;/login\u0026#34;) { 23 NProgress.done() 24 next({ path: \u0026#34;/\u0026#34; }) 25 } else { 26 if (store.getters.user_id \u0026amp;\u0026amp; store.getters.user_id \u0026gt; 0) { 27 next() 28 } else { 29 const { user_id } = await store.dispatch(\u0026#34;user/getUserInfo\u0026#34;) 30 if (user_id \u0026gt; 0) { 31 next({ ...to, replace: true }) 32 } else { 33 ElMessage.error({ message: \u0026#34;个人信息读取失败\u0026#34; }) 34 NProgress.done() 35 next(`/login?redirect=${to.path}`) 36 } 37 } 38 } 39 } else { 40 NProgress.done() 41 if (excludeUris.includes(to.path)) { 42 next() 43 } else { 44 next({ path: \u0026#34;/login\u0026#34; }) 45 } 46 } 47}) 48 49router.afterEach(() =\u0026gt; { 50 NProgress.done() 51}) 1// main.js 2import \u0026#34;./intercept\u0026#34; ","permalink":"https://www.silent-cxl.top/posts/vue-login-permission/","summary":"直接上代码\n1// intercept.js 2import NProgress from \u0026#34;nprogress\u0026#34; 3import \u0026#34;nprogress/nprogress.css\u0026#34; // progress bar style 4import store from \u0026#34;@/store\u0026#34; 5import router from \u0026#34;./router\u0026#34; 6import settings from \u0026#34;./settings\u0026#34; 7import { getToken } from \u0026#34;@/utils/token\u0026#34; 8import { ElMessage } from \u0026#34;element-plus\u0026#34; 9 10NProgress.configure({ showSpinner: false }) 11const excludeUris = [\u0026#34;/login\u0026#34;, \u0026#34;/sso/callback\u0026#34;] 12 13router.beforeEach(async (to, from, next) =\u0026gt; { 14 NProgress.start() 15 // 顺便设置 icon title 16 document.title = to.meta.title 17 ? `${to.meta.title} - ${settings.","title":"Vue3 页面登录拦截器"},{"content":" 添加脚本文件到你期望存放的地址 1#!/bin/bash 2SITEDIR=/www/projects/site 3BAKDIR=/www/baks 4DAYS=7 5DATE=`date +%Y%m%d` 6REMOTE=`gitee/github/gitlab 仓库地址` 7 8# -c 压缩 9# -x 解压 10# -z 支持gzip解压文件 11# -v 显示操作过程 12# -f 使用档名，请留意，在f之后要立即接档名！不要再加参数！ 13tar -zcvf $BAKDIR/site-$DATE-bak.tar.gz $SITEDIR 14cd /www/projects/ 15rm -rf site 16 17git clone $REMOTE site 18 19# 删除过期备份文件 20# $bakdir find 备份文件的地址 21#-type f 类型为普通文件 22#-mtime 7 天之前的文件 23#-exec rm -f 静默删除匹配出来的文件 24# 还可以 -name \u0026#34;site-*-.tar.gz\u0026#34; 名称模糊匹配 25find $BAKDIR -type f -mtime +$DAYS -exec rm -f {} \\; 26 27echo \u0026#34;complete!\u0026#34; 运行 crontab -e 设置定时任务运行上一步添加的文件 ","permalink":"https://www.silent-cxl.top/posts/other-git-auto-publish/","summary":"添加脚本文件到你期望存放的地址 1#!/bin/bash 2SITEDIR=/www/projects/site 3BAKDIR=/www/baks 4DAYS=7 5DATE=`date +%Y%m%d` 6REMOTE=`gitee/github/gitlab 仓库地址` 7 8# -c 压缩 9# -x 解压 10# -z 支持gzip解压文件 11# -v 显示操作过程 12# -f 使用档名，请留意，在f之后要立即接档名！不要再加参数！ 13tar -zcvf $BAKDIR/site-$DATE-bak.tar.gz $SITEDIR 14cd /www/projects/ 15rm -rf site 16 17git clone $REMOTE site 18 19# 删除过期备份文件 20# $bakdir find 备份文件的地址 21#-type f 类型为普通文件 22#-mtime 7 天之前的文件 23#-exec rm -f 静默删除匹配出来的文件 24# 还可以 -name \u0026#34;site-*-.tar.gz\u0026#34; 名称模糊匹配 25find $BAKDIR -type f -mtime +$DAYS -exec rm -f {} \\; 26 27echo \u0026#34;complete!","title":"从远程仓库定时自动发版"},{"content":"安装运行时遇到过的问题 问题：遇到 go install 报错：.... dial tcp 172.217.160.113:443: i/o timeout\n解决，终端执行：go env -w GOPROXY=https://goproxy.cn mac 系统运行时：listen tcp :18081: bind: address already in use\nlsof -ti:18081 kill [port] 待续\u0026hellip;\n","permalink":"https://www.silent-cxl.top/posts/golang-proxy/","summary":"安装运行时遇到过的问题 问题：遇到 go install 报错：.... dial tcp 172.217.160.113:443: i/o timeout\n解决，终端执行：go env -w GOPROXY=https://goproxy.cn mac 系统运行时：listen tcp :18081: bind: address already in use\nlsof -ti:18081 kill [port] 待续\u0026hellip;","title":"Golang 环境搭建"},{"content":" 1# 从服务器上下载文件 2scp [服务器用户名]@[服务器IP]:[服务器文件] [本地目录] 3 4# 上传本地文件到服务器 5scp [本地文件] [服务器用户名]@[服务器IP]:[服务器目录] 6 7# 从服务器下载整个目录 8scp -r [服务器用户名]@[服务器IP]:[服务器目录] [本地目录] 9 10# 上传目录到服务器 11scp -r [本地目录] [服务器用户名]@[服务器IP]:[服务器目录] 12 13# 如果用到非 22 端口则在 scp 后使用 -P 参数 ","permalink":"https://www.silent-cxl.top/posts/linux-scp/","summary":" 1# 从服务器上下载文件 2scp [服务器用户名]@[服务器IP]:[服务器文件] [本地目录] 3 4# 上传本地文件到服务器 5scp [本地文件] [服务器用户名]@[服务器IP]:[服务器目录] 6 7# 从服务器下载整个目录 8scp -r [服务器用户名]@[服务器IP]:[服务器目录] [本地目录] 9 10# 上传目录到服务器 11scp -r [本地目录] [服务器用户名]@[服务器IP]:[服务器目录] 12 13# 如果用到非 22 端口则在 scp 后使用 -P 参数 ","title":"Linux scp 文件管理"},{"content":" 虚拟机版本：CentOS Linux release 7.9.2009 (Core)\n配置文件地址：/etc/sysconfig/network-scripts/ifcfg-enp0s3\n1TYPE=Ethernet 2PROXY_METHOD=none 3BROWSER_ONLY=no 4BOOTPROTO=static 5DEFROUTE=yes 6IPADDR=192.168.120.61 7IPV4_FAILURE_FATAL=no 8IPV6INIT=yes 9IPV6_AUTOCONF=yes 10IPV6_DEFROUTE=yes 11IPV6_FAILURE_FATAL=no 12IPV6_ADDR_GEN_MODE=stable-privacy 13NAME=enp0s3 14UUID=03dae35b-d264-45e4-8d73-8920ab61cd02 15DEVICE=enp0s3 16ONBOOT=yes 17GETRWAY=192.168.56.1 18NETMASK=255.255.255.0 19DNS1=192.168.56.1 ","permalink":"https://www.silent-cxl.top/posts/virtual-network/","summary":" 虚拟机版本：CentOS Linux release 7.9.2009 (Core)\n配置文件地址：/etc/sysconfig/network-scripts/ifcfg-enp0s3\n1TYPE=Ethernet 2PROXY_METHOD=none 3BROWSER_ONLY=no 4BOOTPROTO=static 5DEFROUTE=yes 6IPADDR=192.168.120.61 7IPV4_FAILURE_FATAL=no 8IPV6INIT=yes 9IPV6_AUTOCONF=yes 10IPV6_DEFROUTE=yes 11IPV6_FAILURE_FATAL=no 12IPV6_ADDR_GEN_MODE=stable-privacy 13NAME=enp0s3 14UUID=03dae35b-d264-45e4-8d73-8920ab61cd02 15DEVICE=enp0s3 16ONBOOT=yes 17GETRWAY=192.168.56.1 18NETMASK=255.255.255.0 19DNS1=192.168.56.1 ","title":"Virtual 本地虚拟机网络配置"},{"content":"解决方式：\n无需设置 default-checked-keys 属性\n读取到接口数据后使用 this.$refs.tree.setCheckedNodes(***传入接口返回的节点 keys***) 设置默认； 提交前使用 this.$refs.tree.getCheckedKeys() 再次获取选中的节点并赋值 ","permalink":"https://www.silent-cxl.top/posts/vue-element-tree-checked-bug/","summary":"解决方式：\n无需设置 default-checked-keys 属性\n读取到接口数据后使用 this.$refs.tree.setCheckedNodes(***传入接口返回的节点 keys***) 设置默认； 提交前使用 this.$refs.tree.getCheckedKeys() 再次获取选中的节点并赋值 ","title":"Vue el-tree 的 default-checked-keys 属性默认选中状态bug问题"},{"content":"查看根分区大小 df -h\n1文件系统 类型 容量 已用 可用 已用% 挂载点 2/dev/mapper/centos-root xfs 18G 1.1G 17G 6% / 3devtmpfs devtmpfs 479M 0 479M 0% /dev 4tmpfs tmpfs 489M 0 489M 0% /dev/shm 5tmpfs tmpfs 489M 6.7M 483M 2% /run 6tmpfs tmpfs 489M 0 489M 0% /sys/fs/cgroup 7/dev/sda1 xfs 497M 125M 373M 25% /boot 8tmpfs tmpfs 98M 0 98M 0% /run/user/0 在虚拟机中添加一块物理的磁盘，重起虚拟机 查看磁盘编号 ls /dev/sd*\n1/dev/sda /dev/sda1 /dev/sda2 /dev/sdb 创建pv pvcreate /dev/sdb\n1Physical volume \u0026#34;/dev/sdb\u0026#34; successfully created 把 pv 加入 vg 中，相当于扩充 vg 的大小 先使用 vgs 查看 vg 组 vgs\n1VG #PV #LV #SN Attr VSize VFree 2centos 2 2 0 wz--n- 59.50g 20.04g 扩展 vg，使用 vgextend 命令 vgextend centos /dev/sdb\n把 vg 卷扩展了，在用 vgs 查看一下 vgs\n1VG #PV #LV #SN Attr VSize VFree 2centos 2 2 0 wz--n- 39.50g 20.04g lvs\n1LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert 2 root centos -wi-ao---- 17.47g 3 swap centos -wi-ao---- 2.00g 虽然我们把vg扩展了，但是lv还没有扩展 扩展 lv，使用 lvextend 命令 lvextend -L +20G /dev/mapper/centos-root\n1Size of logical volume centos/root changed from 17.47 GiB (4472 extents) to 37.47 GiB (9592 extents). 2Logical volume root successfully resized 命令使系统重新读取大小 xfs_growfs /dev/mapper/centos-root\n1meta-data=/dev/mapper/centos-root isize=256 agcount=4, agsize=1144832 blks 2 = sectsz=512 attr=2, projid32bit=1 3 = crc=0 finobt=0 4data = bsize=4096 blocks=4579328, imaxpct=25 5 = sunit=0 swidth=0 blks 6naming =version 2 bsize=4096 ascii-ci=0 ftype=0 7log =internal bsize=4096 blocks=2560, version=2 8 = sectsz=512 sunit=0 blks, lazy-count=1 9realtime =none extsz=4096 blocks=0, rtextents=0 10data blocks changed from 4579328 to 9822208 再使用 df -h 查看 df -h\n1文件系统 容量 已用 可用 已用% 挂载点 2/dev/mapper/centos-root 38G 1.1G 37G 3% / 3devtmpfs 479M 0 479M 0% /dev 4tmpfs 489M 0 489M 0% /dev/shm 5tmpfs 489M 6.7M 483M 2% /run 6tmpfs 489M 0 489M 0% /sys/fs/cgroup 7/dev/sda1 497M 125M 373M 25% /boot 8tmpfs 98M 0 98M 0% /run/user/0 转载自：虚拟机扩容（/dev/mapper/centos-root 空间不足\n","permalink":"https://www.silent-cxl.top/posts/virtual-space-not-enough/","summary":"查看根分区大小 df -h\n1文件系统 类型 容量 已用 可用 已用% 挂载点 2/dev/mapper/centos-root xfs 18G 1.1G 17G 6% / 3devtmpfs devtmpfs 479M 0 479M 0% /dev 4tmpfs tmpfs 489M 0 489M 0% /dev/shm 5tmpfs tmpfs 489M 6.7M 483M 2% /run 6tmpfs tmpfs 489M 0 489M 0% /sys/fs/cgroup 7/dev/sda1 xfs 497M 125M 373M 25% /boot 8tmpfs tmpfs 98M 0 98M 0% /run/user/0 在虚拟机中添加一块物理的磁盘，重起虚拟机 查看磁盘编号 ls /dev/sd*\n1/dev/sda /dev/sda1 /dev/sda2 /dev/sdb 创建pv pvcreate /dev/sdb","title":"Virtual 虚拟机扩容（/dev/mapper/centos-root 空间不足）"},{"content":"git bash 进入项目目录：\n1git config --global credential.helper store 输入以上命令后，重新拉取代码再次输入账号密码，输入后会记住，以后拉代码不需要再输入。\n","permalink":"https://www.silent-cxl.top/posts/git-pull-repeat-enter-pass/","summary":"git bash 进入项目目录：\n1git config --global credential.helper store 输入以上命令后，重新拉取代码再次输入账号密码，输入后会记住，以后拉代码不需要再输入。","title":"Git 解决每次 git pull 需要输入账号密码"},{"content":" 你好！我是 silent，中文名：程晓良，很高兴你能进入我的博客，如有互相交流的可添加微信：Silent-Cxl（备注：技术交流）。\n关于我 我是一名从服务行业转行的 PHP/Golang 开发，会点前端技能，能用 vue、jQuery 等前端框架。\n13 年毕业的我在酒店里做服务员，经过几年的努力并没有什么出路，17年毅然准备转行，但是却并没有头绪，恰巧碰上技术开发岗位的招聘，果断选择尝试，然而没有成功入职，却交了智商费用 500，而后自学了前端到深圳干了一年前端开发，再通过自学 PHP 转到了后端开发，21 年了解到了 golang 的火爆又开始转到了 golang，如今在深圳一家上市公司担任开发。\n","permalink":"https://www.silent-cxl.top/about/","summary":"你好！我是 silent，中文名：程晓良，很高兴你能进入我的博客，如有互相交流的可添加微信：Silent-Cxl（备注：技术交流）。\n关于我 我是一名从服务行业转行的 PHP/Golang 开发，会点前端技能，能用 vue、jQuery 等前端框架。\n13 年毕业的我在酒店里做服务员，经过几年的努力并没有什么出路，17年毅然准备转行，但是却并没有头绪，恰巧碰上技术开发岗位的招聘，果断选择尝试，然而没有成功入职，却交了智商费用 500，而后自学了前端到深圳干了一年前端开发，再通过自学 PHP 转到了后端开发，21 年了解到了 golang 的火爆又开始转到了 golang，如今在深圳一家上市公司担任开发。","title":"关于 Silent"},{"content":" 首先安装 air 运行命令：go install github.com/cosmtrek/air@latest 项目根目录创建 air 配置文件：.air.conf mac 系统文件内容\n1# .air.conf 文件内容 2root = \u0026#34;.\u0026#34; 3tmp_dir = \u0026#34;tmp\u0026#34; 4 5[build] 6# Just plain old shell command. You could use `make` as well. 7cmd = \u0026#34;go build -o ./tmp/main ./web/main.go\u0026#34; 8# Binary file yields from `cmd`. 9bin = \u0026#34;tmp/main\u0026#34; 10# Customize binary. 11full_bin = \u0026#34;APP_ENV=dev APP_USER=air ./tmp/main\u0026#34; 12# Watch these filename extensions. 13include_ext = [\u0026#34;go\u0026#34;, \u0026#34;tpl\u0026#34;, \u0026#34;tmpl\u0026#34;, \u0026#34;html\u0026#34;] 14# Ignore these filename extensions or directories. 15exclude_dir = [\u0026#34;storage\u0026#34;, \u0026#34;web/storage\u0026#34;] 16# Watch these directories if you specified. 17include_dir = [] 18# Exclude files. 19exclude_file = [] 20# This log file places in your tmp_dir. 21log = \u0026#34;air.log\u0026#34; 22# It\u0026#39;s not necessary to trigger build each time file changes if it\u0026#39;s too frequent. 23delay = 1000 # ms 24# Stop running old binary when build errors occur. 25stop_on_error = true 26# Send Interrupt signal before killing process (windows does not support this feature) 27send_interrupt = false 28# Delay after sending Interrupt signal 29kill_delay = 500 # ms 30 31[log] 32# Show log time 33time = false 34 35[color] 36# Customize each part\u0026#39;s color. If no color found, use the raw app log. 37main = \u0026#34;magenta\u0026#34; 38watcher = \u0026#34;cyan\u0026#34; 39build = \u0026#34;yellow\u0026#34; 40runner = \u0026#34;green\u0026#34; 41 42[misc] 43# Delete tmp directory on exit 44clean_on_exit = true windows 系统文件内容\n1# 工作目录 2# 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下 3root = \u0026#34;.\u0026#34; 4tmp_dir = \u0026#34;tmp\u0026#34; 5 6[build] 7# 只需要写你平常编译使用的shell命令。你也可以使用 `make` 8cmd = \u0026#34;go build -o ./tmp/main.exe ./public/main.go\u0026#34; 9# 由`cmd`命令得到的二进制文件名 10bin = \u0026#34;tmp/main.exe\u0026#34; 11# 自定义的二进制，可以添加额外的编译标识例如添加 GIN_MODE=release 12# full_bin = \u0026#34;SET APP_ENV=dev \u0026amp; SET APP_USER=air \u0026amp; ./tmp/main.exe\u0026#34; 13full_bin = \u0026#34;./tmp/main.exe\u0026#34; 14# 监听以下文件扩展名的文件. 15include_ext = [\u0026#34;go\u0026#34;, \u0026#34;tpl\u0026#34;, \u0026#34;tmpl\u0026#34;, \u0026#34;html\u0026#34;] 16# 忽略这些文件扩展名或目录 17exclude_dir = [\u0026#34;storage\u0026#34;, \u0026#34;public/storage\u0026#34;, \u0026#34;tmp\u0026#34;] 18# 监听以下指定目录的文件 19include_dir = [] 20# 排除以下文件 21exclude_file = [] 22# 如果文件更改过于频繁，则没有必要在每次更改时都触发构建。可以设置触发构建的延迟时间 23delay = 1000 # ms 24# 发生构建错误时，停止运行旧的二进制文件。 25stop_on_error = true 26# air的日志文件名，该日志文件放置在你的`tmp_dir`中 27log = \u0026#34;air_errors.log\u0026#34; 28 29[log] 30# 显示日志时间 31time = true 32 33[color] 34# 自定义每个部分显示的颜色。如果找不到颜色，使用原始的应用程序日志。 35main = \u0026#34;magenta\u0026#34; 36watcher = \u0026#34;cyan\u0026#34; 37build = \u0026#34;yellow\u0026#34; 38runner = \u0026#34;green\u0026#34; 39 40[misc] 41# 退出时删除tmp目录 42clean_on_exit = true 运行命令：air 或 air -d ","permalink":"https://www.silent-cxl.top/posts/golang-air/","summary":"首先安装 air 运行命令：go install github.com/cosmtrek/air@latest 项目根目录创建 air 配置文件：.air.conf mac 系统文件内容\n1# .air.conf 文件内容 2root = \u0026#34;.\u0026#34; 3tmp_dir = \u0026#34;tmp\u0026#34; 4 5[build] 6# Just plain old shell command. You could use `make` as well. 7cmd = \u0026#34;go build -o ./tmp/main ./web/main.go\u0026#34; 8# Binary file yields from `cmd`. 9bin = \u0026#34;tmp/main\u0026#34; 10# Customize binary. 11full_bin = \u0026#34;APP_ENV=dev APP_USER=air ./tmp/main\u0026#34; 12# Watch these filename extensions. 13include_ext = [\u0026#34;go\u0026#34;, \u0026#34;tpl\u0026#34;, \u0026#34;tmpl\u0026#34;, \u0026#34;html\u0026#34;] 14# Ignore these filename extensions or directories.","title":"golang air 热更新使用"},{"content":"编写 proto 文件 1// role.proto 文件 2syntax = \u0026#34;proto3\u0026#34;; 3 4option go_package = \u0026#34;./marketing\u0026#34;; 5 6package marketing; 7 8message RoleCreateReq { 9 string role_name = 1; 10} 1// user.proto 文件 2syntax = \u0026#34;proto3\u0026#34;; 3 4option go_package = \u0026#34;./rbac\u0026#34;; 5 6package rbac; 7import \u0026#34;pb/role.proto\u0026#34;; // 以执行 goctl 命令为起始路径 8 9message UserCreateReq { 10 string username = 1; 11 string email = 2; 12} 13 14message BaseResp { 15 int64 code = 1; 16} 17 18service RbacCenter{ 19 // RPC 服务 20 rpc RoleCreate(RoleCreateReq) returns(BaseResp); 21 22 rpc UserCreate(UserCreateReq) returns(BaseResp); 23} 两个文件放在同一目录内\n执行 goctl 与 原始 protoc 命令 1goctl rpc protoc ./pb/user.proto --go_out=. --go-grpc_out=. --zrpc_out=. -style goZero # 生成代码 2 3protoc ./pb/role.proto --go_out=. --go-grpc_out=. # 生成 pb.go 数据结构文件 进入 rbaccenter 目录映射一下 type 数据类型\n","permalink":"https://www.silent-cxl.top/posts/gozero-import-other-proto/","summary":"编写 proto 文件 1// role.proto 文件 2syntax = \u0026#34;proto3\u0026#34;; 3 4option go_package = \u0026#34;./marketing\u0026#34;; 5 6package marketing; 7 8message RoleCreateReq { 9 string role_name = 1; 10} 1// user.proto 文件 2syntax = \u0026#34;proto3\u0026#34;; 3 4option go_package = \u0026#34;./rbac\u0026#34;; 5 6package rbac; 7import \u0026#34;pb/role.proto\u0026#34;; // 以执行 goctl 命令为起始路径 8 9message UserCreateReq { 10 string username = 1; 11 string email = 2; 12} 13 14message BaseResp { 15 int64 code = 1; 16} 17 18service RbacCenter{ 19 // RPC 服务 20 rpc RoleCreate(RoleCreateReq) returns(BaseResp); 21 22 rpc UserCreate(UserCreateReq) returns(BaseResp); 23} 两个文件放在同一目录内","title":"go-zero goctl 使用 proto 引入其他 proto 文件"},{"content":"资源清单格式 1apiVersion: group/apiversion # 如果没有给定 group 名称，那么默认为 core，可以使用 kubectl api-versions # 获取当前 k8s 版本上所有的 apiVersion 版本信息( 每个版本可能不同 ) 2kind: #资源类别 3metadata： #资源元数据 4 name 5 namespace 6 lables 7 annotations # 主要目的是方便用户阅读查找 8spec: # 期望的状态（disired state） 9status：# 当前状态，本字段有 Kubernetes 自身维护，用户不能去定义 资源清单的常用命令 获取 apiversion 版本信息\n1[root@k8s-master01 ~]# kubectl api-versions 2admissionregistration.k8s.io/v1beta1 3apiextensions.k8s.io/v1beta1 4apiregistration.k8s.io/v1 5apiregistration.k8s.io/v1beta1 6apps/v1 7......(以下省略) 获取资源的 apiVersion 版本信息\n1[root@k8s-master01 ~]# kubectl explain pod 2KIND: Pod 3VERSION: v1 4.....(以下省略) 5 6[root@k8s-master01 ~]# kubectl explain Ingress 7KIND: Ingress 8VERSION: extensions/v1beta1 获取字段设置帮助文档\n1[root@k8s-master01 ~]# kubectl explain pod 2KIND: Pod 3VERSION: v1 4 5DESCRIPTION: 6 Pod is a collection of containers that can run on a host. This resource is 7 created by clients and scheduled onto hosts. 8 9FIELDS: 10 apiVersion \u0026lt;string\u0026gt; 11 ........ 12 ........ 字段配置格式\n1apiVersion \u0026lt;string\u0026gt; #表示字符串类型 2metadata \u0026lt;Object\u0026gt; #表示需要嵌套多层字段 3labels \u0026lt;map[string]string\u0026gt; #表示由k:v组成的映射 4finalizers \u0026lt;[]string\u0026gt; #表示字串列表 5ownerReferences \u0026lt;[]Object\u0026gt; #表示对象列表 6hostPID \u0026lt;boolean\u0026gt; #布尔类型 7priority \u0026lt;integer\u0026gt; #整型 8name \u0026lt;string\u0026gt; -required- #如果类型后面接 -required-，表示为必填字段 通过定义清单文件创建 Pod 1apiVersion: v1 # 根绝对象类型可以查询 kubectl explain pod 取 version 的值 2kind: Pod # 对象类型先确定 3metadata: 4 name: pod-demo 5 namespace: default 6 labels: 7 app: myapp 8spec: 9 containers: 10 - name: myapp-1 11 image: harbor.hongfu.com/library/myapp:v1 12 - name: busybox-1 13 image: harbor.hongfu.com/library/busybox:v1 14 command: # 替换镜像默认封装的命令 15 - \u0026#34;/bin/sh\u0026#34; 16 - \u0026#34;-c\u0026#34; 17 - \u0026#34;sleep 3600\u0026#34; 1kubectl get pod xx.xx.xx -o yaml 2\u0026lt;!--使用 -o 参数 加 yaml，可以将资源的配置以 yaml的格式输出出来，也可以使用json，输出为json格式--\u0026gt; 1kubectl create -f [yaml-filename] # 创建资源 2kubectl explain pod # 获取 kind 所属的 apiVersion 3 # 读取子对象配置 4 kubectl explain pod.metadata 5kubectl get pod 6 -n kube-system [pod-name] -o yaml # 查看某个 pod yaml 配置清单 -n 名称控件，默认 default 7 -o wide 8kubectl exec -it [pod-name] -c [container-name] # 进入某个 pod 的容器 9kubectl logs [pod-name] 10kubectl describe pod [pod-name] 11kubectl delete [pod | svc] [--all | pod-name] # 删除 pod、service ","permalink":"https://www.silent-cxl.top/posts/k8s-3-list/","summary":"资源清单格式 1apiVersion: group/apiversion # 如果没有给定 group 名称，那么默认为 core，可以使用 kubectl api-versions # 获取当前 k8s 版本上所有的 apiVersion 版本信息( 每个版本可能不同 ) 2kind: #资源类别 3metadata： #资源元数据 4 name 5 namespace 6 lables 7 annotations # 主要目的是方便用户阅读查找 8spec: # 期望的状态（disired state） 9status：# 当前状态，本字段有 Kubernetes 自身维护，用户不能去定义 资源清单的常用命令 获取 apiversion 版本信息\n1[root@k8s-master01 ~]# kubectl api-versions 2admissionregistration.k8s.io/v1beta1 3apiextensions.k8s.io/v1beta1 4apiregistration.k8s.io/v1 5apiregistration.k8s.io/v1beta1 6apps/v1 7......(以下省略) 获取资源的 apiVersion 版本信息\n1[root@k8s-master01 ~]# kubectl explain pod 2KIND: Pod 3VERSION: v1 4.....(以下省略) 5 6[root@k8s-master01 ~]# kubectl explain Ingress 7KIND: Ingress 8VERSION: extensions/v1beta1 获取字段设置帮助文档","title":"K8s - 资源清单"},{"content":"kube-proxy开启ipvs的前置条件 1modprobe br_netfilter 2 3cat \u0026gt; /etc/sysconfig/modules/ipvs.modules \u0026lt;\u0026lt;EOF 4#!/bin/bash 5modprobe -- ip_vs 6modprobe -- ip_vs_rr 7modprobe -- ip_vs_wrr 8modprobe -- ip_vs_sh 9modprobe -- nf_conntrack_ipv4 10EOF 11 12chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; bash /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4 如果报错：modprobe: FATAL: Module nf_conntrack_ipv4 not found. 内核高版本的 nf_conntrack_ipv4 已被 nf_conntrack 替换，将以上的 nf_conntrack_ipv4 改为 nf_conntrack 重新执行。\n安装 Docker 软件 1yum install -y yum-utils device-mapper-persistent-data lvm2 # docker 依赖包 2 3# docker 镜像源 4yum-config-manager \\ 5 --add-repo \\ 6 http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 7 8yum install -y docker-ce 9 10## 创建 /etc/docker 目录 11mkdir /etc/docker 12 13# 配置 daemon. 14cat \u0026gt; /etc/docker/daemon.json \u0026lt;\u0026lt;EOF 15{ 16 \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], 17 \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, 18 \u0026#34;log-opts\u0026#34;: { 19 \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; 20 }, 21 \u0026#34;insecure-registries\u0026#34;: [\u0026#34;harbor.hongfu.com\u0026#34;], 22 \u0026#34;registry-mirrors\u0026#34;: [ 23 \u0026#34;--阿里云镜像加速地址--\u0026#34; 24 ] 25} 26EOF 27mkdir -p /etc/systemd/system/docker.service.d 28 29# 重启docker服务 30systemctl daemon-reload \u0026amp;\u0026amp; systemctl restart docker \u0026amp;\u0026amp; systemctl enable docker 安装 Kubeadm （主从配置） 1cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo 2[kubernetes] 3name=Kubernetes 4baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 5enabled=1 6gpgcheck=0 7repo_gpgcheck=0 8gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg 9EOF 10 11yum -y install kubeadm-1.15.1 kubectl-1.15.1 kubelet-1.15.1 12systemctl enable kubelet.service 导入 k8s 镜像，有梯子可以直接下载：kubeadm config images pull\nv1.15.1 版本的镜像网盘下载地址如下： 链接: https://pan.baidu.com/s/1aAHyZXVjHr0Wclh6xFJV2w 提取码: b269\n1# 8s.gcr.io/kube-apiserver 2# 8s.gcr.io/kube-proxy 3# 8s.gcr.io/kube-scheduler 4# 8s.gcr.io/kube-controller-manager 5# 8s.gcr.io/etcd 6# 8s.gcr.io/pause 7# 8s.gcr.io/coredns/coredns 8 9docker save [-o | \u0026gt;] 保存的镜像名.tar [镜像名:tag | 镜像ID] # 如果以镜像ID导出，导入时需要自己重新修改镜像名称和 tag 10docker load [-i | \u0026lt;] 保存的镜像名.tar 11docker tag 镜像ID 镜像名:镜像tag 初始化主节点 1kubeadm config print init-defaults \u0026gt; kubeadm-config.yaml # 打印一个初始化配置到 kubeadm-config.yaml 文件 2 3# 调整刚刚打印出来的 kubeadm-config.yaml 文件修改点如下： 4localAPIEndpoint: 5 advertiseAddress: 192.168.66.10 # 本机IP 6 kubernetesVersion: v1.15.1 7networking: 8 podSubnet: \u0026#34;10.244.0.0/16\u0026#34; # flannel 要求网段 9 serviceSubnet: 10.96.0.0/12 10--- 11apiVersion: kubeproxy.config.k8s.io/v1alpha1 12kind: KubeProxyConfiguration 13featureGates: 14 SupportIPVSProxyMode: true 15mode: ipvs 16 17kubeadm init --config=kubeadm-config.yaml --experimental-upload-certs | tee kubeadm-init.log 安装日志\n1Flag --experimental-upload-certs has been deprecated, use --upload-certs instead 2W0719 15:03:54.748649 7060 strict.go:54] error unmarshaling configuration schema.GroupVersionKind{Group:\u0026#34;kubeadm.k8s.io\u0026#34;, Version:\u0026#34;v1beta2\u0026#34;, Kind:\u0026#34;InitConfiguration\u0026#34;}: error unmarshaling JSON: while decoding JSON: json: unknown field \u0026#34;kubernetesVersion\u0026#34; 3[init] Using Kubernetes version: v1.15.1 4[preflight] Running pre-flight checks 5\t[WARNING IsDockerSystemdCheck]: detected \u0026#34;cgroupfs\u0026#34; as the Docker cgroup driver. The recommended driver is \u0026#34;systemd\u0026#34;. Please follow the guide at https://kubernetes.io/docs/setup/cri/ 6\t[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 20.10.10. Latest validated version: 18.09 7[preflight] Pulling images required for setting up a Kubernetes cluster 8[preflight] This might take a minute or two, depending on the speed of your internet connection 9[preflight] You can also perform this action in beforehand using \u0026#39;kubeadm config images pull\u0026#39; 10[kubelet-start] Writing kubelet environment file with flags to file \u0026#34;/var/lib/kubelet/kubeadm-flags.env\u0026#34; 11[kubelet-start] Writing kubelet configuration to file \u0026#34;/var/lib/kubelet/config.yaml\u0026#34; 12[kubelet-start] Activating the kubelet service 13[certs] Using certificateDir folder \u0026#34;/etc/kubernetes/pki\u0026#34; 14[certs] Generating \u0026#34;front-proxy-ca\u0026#34; certificate and key 15[certs] Generating \u0026#34;front-proxy-client\u0026#34; certificate and key 16[certs] Generating \u0026#34;etcd/ca\u0026#34; certificate and key 17[certs] Generating \u0026#34;etcd/server\u0026#34; certificate and key 18[certs] etcd/server serving cert is signed for DNS names [master-1 localhost] and IPs [192.168.0.101 127.0.0.1 ::1] 19[certs] Generating \u0026#34;etcd/peer\u0026#34; certificate and key 20[certs] etcd/peer serving cert is signed for DNS names [master-1 localhost] and IPs [192.168.0.101 127.0.0.1 ::1] 21[certs] Generating \u0026#34;etcd/healthcheck-client\u0026#34; certificate and key 22[certs] Generating \u0026#34;apiserver-etcd-client\u0026#34; certificate and key 23[certs] Generating \u0026#34;ca\u0026#34; certificate and key 24[certs] Generating \u0026#34;apiserver\u0026#34; certificate and key 25[certs] apiserver serving cert is signed for DNS names [master-1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.0.101] 26[certs] Generating \u0026#34;apiserver-kubelet-client\u0026#34; certificate and key 27[certs] Generating \u0026#34;sa\u0026#34; key and public key 28[kubeconfig] Using kubeconfig folder \u0026#34;/etc/kubernetes\u0026#34; 29[kubeconfig] Writing \u0026#34;admin.conf\u0026#34; kubeconfig file 30[kubeconfig] Writing \u0026#34;kubelet.conf\u0026#34; kubeconfig file 31[kubeconfig] Writing \u0026#34;controller-manager.conf\u0026#34; kubeconfig file 32[kubeconfig] Writing \u0026#34;scheduler.conf\u0026#34; kubeconfig file 33[control-plane] Using manifest folder \u0026#34;/etc/kubernetes/manifests\u0026#34; 34[control-plane] Creating static Pod manifest for \u0026#34;kube-apiserver\u0026#34; 35[control-plane] Creating static Pod manifest for \u0026#34;kube-controller-manager\u0026#34; 36[control-plane] Creating static Pod manifest for \u0026#34;kube-scheduler\u0026#34; 37[etcd] Creating static Pod manifest for local etcd in \u0026#34;/etc/kubernetes/manifests\u0026#34; 38[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \u0026#34;/etc/kubernetes/manifests\u0026#34;. This can take up to 4m0s 39[kubelet-check] Initial timeout of 40s passed. 40[apiclient] All control plane components are healthy after 40.503426 seconds 41[upload-config] Storing the configuration used in ConfigMap \u0026#34;kubeadm-config\u0026#34; in the \u0026#34;kube-system\u0026#34; Namespace 42[kubelet] Creating a ConfigMap \u0026#34;kubelet-config-1.15\u0026#34; in namespace kube-system with the configuration for the kubelets in the cluster 43[upload-certs] Storing the certificates in Secret \u0026#34;kubeadm-certs\u0026#34; in the \u0026#34;kube-system\u0026#34; Namespace 44[upload-certs] Using certificate key: 45df949aae79dfa71766351e9ca59deaf1dfcee045d46121d037881d42ddcbcf06 46[mark-control-plane] Marking the node master-1 as control-plane by adding the label \u0026#34;node-role.kubernetes.io/master=\u0026#39;\u0026#39;\u0026#34; 47[mark-control-plane] Marking the node master-1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule] 48[bootstrap-token] Using token: abcdef.0123456789abcdef 49[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles 50[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials 51[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token 52[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster 53[bootstrap-token] Creating the \u0026#34;cluster-info\u0026#34; ConfigMap in the \u0026#34;kube-public\u0026#34; namespace 54[addons] Applied essential addon: CoreDNS 55[addons] Applied essential addon: kube-proxy 56 57Your Kubernetes control-plane has initialized successfully! 58 59To start using your cluster, you need to run the following as a regular user: 60 61 mkdir -p $HOME/.kube 62 sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config 63 sudo chown $(id -u):$(id -g) $HOME/.kube/config 64 65You should now deploy a pod network to the cluster. 66Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: 67 https://kubernetes.io/docs/concepts/cluster-administration/addons/ 68 69Then you can join any number of worker nodes by running the following on each as root: 70 71kubeadm join 192.168.0.101:6443 --token abcdef.0123456789abcdef \\ 72 --discovery-token-ca-cert-hash sha256:39a62e1abd02ce75c82b39cb81798446266316fbc16ebd286049116184c82287 如果报错：unknown flag: --experimental-upload-certs 可能是版本升级的原因，将以上的 --experimental-upload-certs 改为 --upload-certs 重新执行。\n加入主节点以及其余工作节点 1执行安装日志中的加入命令即可 使用 flannel 部署 k8s 的扁平化网络 首先需要下载 flannel 的 docker 镜像：quay.io/coreos/flannel:v0.12.0-amd64 flannel 镜像与配置文件地址如下： 链接: https://pan.baidu.com/s/13g41uMWuQEu-CSpfhWmTTA 提取码: a2nn\n1# -f 后为配置文件，如已下载可直接指向下载了的文件 2kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 附加：已启动的 master 查寻 token 和 hash 值加入\n1# 查询 token 2kubeadm token list 3# 查询 hash 值 4openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u0026gt;/dev/null | openssl dgst -sha256 -hex | sed \u0026#39;s/^.* //\u0026#39; ","permalink":"https://www.silent-cxl.top/posts/k8s-2-install/","summary":"kube-proxy开启ipvs的前置条件 1modprobe br_netfilter 2 3cat \u0026gt; /etc/sysconfig/modules/ipvs.modules \u0026lt;\u0026lt;EOF 4#!/bin/bash 5modprobe -- ip_vs 6modprobe -- ip_vs_rr 7modprobe -- ip_vs_wrr 8modprobe -- ip_vs_sh 9modprobe -- nf_conntrack_ipv4 10EOF 11 12chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; bash /etc/sysconfig/modules/ipvs.modules \u0026amp;\u0026amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4 如果报错：modprobe: FATAL: Module nf_conntrack_ipv4 not found. 内核高版本的 nf_conntrack_ipv4 已被 nf_conntrack 替换，将以上的 nf_conntrack_ipv4 改为 nf_conntrack 重新执行。\n安装 Docker 软件 1yum install -y yum-utils device-mapper-persistent-data lvm2 # docker 依赖包 2 3# docker 镜像源 4yum-config-manager \\ 5 --add-repo \\ 6 http://mirrors.","title":"K8s - Kubeadm 部署安装"},{"content":"设置系统主机名 1hostnamectl set-hostname k8s-master01 安装依赖包 1yum install -y conntrack ntpdate ntp ipvsadm ipset iptables curl sysstat libseccomp wget vim net-tools git 设置 Iptables 1systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld 2yum -y install iptables-services \u0026amp;\u0026amp; systemctl start iptables \u0026amp;\u0026amp; systemctl enable iptables \u0026amp;\u0026amp; iptables -F \u0026amp;\u0026amp; service iptables save 关闭 SELINUX 1swapoff -a \u0026amp;\u0026amp; sed -i \u0026#39;/ swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab 2setenforce 0 \u0026amp;\u0026amp; sed -i \u0026#39;s/^SELINUX=.*/SELINUX=disabled/\u0026#39; /etc/selinux/config 调整内核参数 1cat \u0026gt; kubernetes.conf \u0026lt;\u0026lt;EOF 2net.bridge.bridge-nf-call-iptables=1 # ipv4 的情况下所有经过网桥的网络必需经过 iptables 处理 3net.bridge.bridge-nf-call-ip6tables=1 # ipv6 的情况下所有经过网桥的网络必需经过 iptables 处理 4net.ipv4.ip_forward=1 #数据包转发 5net.ipv4.tcp_tw_recycle=0 6vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它 7vm.overcommit_memory=1 # 不检查物理内存是否够用 8vm.panic_on_oom=0 # 开启 OOM\t9fs.inotify.max_user_instances=8192 10fs.inotify.max_user_watches=1048576 11fs.file-max=52706963 12fs.nr_open=52706963 13net.ipv6.conf.all.disable_ipv6=1 14net.netfilter.nf_conntrack_max=2310720 15EOF 16cp kubernetes.conf /etc/sysctl.d/kubernetes.conf 17sysctl -p /etc/sysctl.d/kubernetes.conf 调整系统时区 1# 设置系统时区为 中国/上海 2timedatectl set-timezone Asia/Shanghai 3# 将当前的 UTC 时间写入硬件时钟 4timedatectl set-local-rtc 0 5# 重启依赖于系统时间的服务 6systemctl restart rsyslog 7systemctl restart crond 关闭系统不需要服务 1systemctl stop postfix \u0026amp;\u0026amp; systemctl disable postfix 设置日志 1mkdir /var/log/journal # 持久化保存日志的目录 2mkdir /etc/systemd/journald.conf.d 3cat \u0026gt; /etc/systemd/journald.conf.d/99-prophet.conf \u0026lt;\u0026lt;EOF 4[Journal] 5# 持久化保存到磁盘 6Storage=persistent 7 8# 压缩历史日志 9Compress=yes 10 11SyncIntervalSec=5m 12RateLimitInterval=30s 13RateLimitBurst=1000 14 15# 最大占用空间 10G 16SystemMaxUse=10G 17 18# 单日志文件最大 200M 19SystemMaxFileSize=200M 20 21# 日志保存时间 2 周 22MaxRetentionSec=2week 23 24# 不将日志转发到 syslog 25ForwardToSyslog=no 26EOF 27systemctl restart systemd-journald 升级系统内核为 4.44 CentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定，例如： rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n1rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 2# 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！ 3yum --enablerepo=elrepo-kernel install -y kernel-lt 4# 设置开机从新内核启动 5grub2-set-default \u0026#39;CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)\u0026#39; ","permalink":"https://www.silent-cxl.top/posts/k8s-1-init/","summary":"设置系统主机名 1hostnamectl set-hostname k8s-master01 安装依赖包 1yum install -y conntrack ntpdate ntp ipvsadm ipset iptables curl sysstat libseccomp wget vim net-tools git 设置 Iptables 1systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld 2yum -y install iptables-services \u0026amp;\u0026amp; systemctl start iptables \u0026amp;\u0026amp; systemctl enable iptables \u0026amp;\u0026amp; iptables -F \u0026amp;\u0026amp; service iptables save 关闭 SELINUX 1swapoff -a \u0026amp;\u0026amp; sed -i \u0026#39;/ swap / s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab 2setenforce 0 \u0026amp;\u0026amp; sed -i \u0026#39;s/^SELINUX=.*/SELINUX=disabled/\u0026#39; /etc/selinux/config 调整内核参数 1cat \u0026gt; kubernetes.","title":"K8s - 系统初始化"}]